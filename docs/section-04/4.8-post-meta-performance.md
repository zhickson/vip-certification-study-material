# 4.8 Post Meta Performance - Study Notes

## Overview

Post meta (custom fields) can become a performance bottleneck when used incorrectly. Understanding the performance challenges of bloated post meta usage and knowing how to optimize queries is essential for scalable WordPress sites.

**Key Reference:** [Custom Fields - WordPress Developer Resources](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)

---

## 1. Performance Challenges of Bloated Post Meta

### Common Problems

**1. Large Meta Values:**
```php
// ❌ BAD - Storing large data in meta
update_post_meta( $post_id, 'full_content', $very_long_text ); // 50KB+
update_post_meta( $post_id, 'export_data', $huge_array ); // Serialized, 100KB+
```

**Issues:**
- Increases table size
- Slows down queries
- Memory overhead
- Backup/restore issues

**2. Too Many Meta Keys:**
```php
// ❌ BAD - Creating many meta entries
for ( $i = 1; $i <= 100; $i++ ) {
	update_post_meta( $post_id, "field_{$i}", "value_{$i}" );
}
// Creates 100 rows in wp_postmeta
```

**Issues:**
- Table bloat
- Slow meta queries
- Index overhead

**3. Inappropriate Data Types:**
```php
// ❌ BAD - Storing structured data in meta
update_post_meta( $post_id, 'product_data', array(
	'name' => 'Product',
	'price' => 99.99,
	'description' => '...',
	'images' => array( /* many items */ ),
) );
```

**Issues:**
- Serialization overhead
- Can't query efficiently
- Hard to index

---

## 2. Avoiding Large or Inappropriate Data

### Use Post Content Instead

**For Large Text:**
```php
// ❌ BAD - Large text in meta
update_post_meta( $post_id, 'long_description', $very_long_text );

// ✅ GOOD - Use post content
wp_update_post( array(
	'ID' => $post_id,
	'post_content' => $very_long_text,
) );
```

### Use Custom Tables

**For Structured Data:**
```php
// ❌ BAD - Complex data in meta
update_post_meta( $post_id, 'product_specs', $complex_array );

// ✅ GOOD - Custom table
global $wpdb;
$wpdb->insert(
	$wpdb->prefix . 'product_specs',
	array(
		'post_id' => $post_id,
		'spec_name' => 'weight',
		'spec_value' => '1.5kg',
	),
	array( '%d', '%s', '%s' )
);
```

### Use Taxonomies

**For Categorization:**
```php
// ❌ BAD - Categories in meta
update_post_meta( $post_id, 'product_category', 'electronics' );

// ✅ GOOD - Use taxonomy
wp_set_object_terms( $post_id, 'electronics', 'product_category' );
```

### Limit Meta Usage

**Best Practices:**
- Keep meta values small (< 1KB)
- Use meta for simple key-value pairs
- Store large/complex data elsewhere
- Limit number of meta keys per post

---

## 3. Optimizing Queries with Meta Joins

### Understanding Meta Joins

**WordPress Meta Query:**
```php
$query = new WP_Query( array(
	'meta_query' => array(
		array(
			'key' => 'price',
			'value' => 100,
			'compare' => '>=',
		),
	),
) );
```

**Generated SQL:**
```sql
SELECT wp_posts.*
FROM wp_posts
INNER JOIN wp_postmeta ON (wp_posts.ID = wp_postmeta.post_id)
WHERE 1=1
AND wp_postmeta.meta_key = 'price'
AND CAST(wp_postmeta.meta_value AS SIGNED) >= 100
```

### Add Indexes

**Composite Index:**
```sql
-- Add composite index for meta queries
CREATE INDEX idx_meta_key_value ON wp_postmeta(meta_key(50), meta_value(50));

-- Helps with:
-- - Exact key/value matches
-- - Range queries on meta_value
-- - Sorting by meta_value
```

**Post ID Index:**
```sql
-- WordPress creates this automatically
CREATE INDEX post_id ON wp_postmeta(post_id);

-- Essential for JOINs
```

### Optimize Meta Query Structure

**1. Use Specific Keys:**
```php
// ✅ GOOD - Specific key
$query = new WP_Query( array(
	'meta_key' => 'price',
	'meta_value' => 100,
	'meta_compare' => '>=',
) );

// ❌ BAD - LIKE query
$query = new WP_Query( array(
	'meta_query' => array(
		array(
			'key' => 'price',
			'value' => '100',
			'compare' => 'LIKE', // Slow!
		),
	),
) );
```

**2. Limit Meta Queries:**
```php
// ✅ GOOD - Limit results
$query = new WP_Query( array(
	'meta_query' => array(
		array(
			'key' => 'featured',
			'value' => 'yes',
		),
	),
	'posts_per_page' => 20,
) );
```

**3. Use Proper Compare:**
```php
// ✅ GOOD - Exact match
$query = new WP_Query( array(
	'meta_query' => array(
		array(
			'key' => 'status',
			'value' => 'active',
			'compare' => '=',
		),
	),
) );
```

### Multiple Meta Queries

**Optimize AND Queries:**
```php
// ✅ GOOD - Multiple conditions
$query = new WP_Query( array(
	'meta_query' => array(
		'relation' => 'AND',
		array(
			'key' => 'price',
			'value' => 100,
			'compare' => '>=',
		),
		array(
			'key' => 'stock',
			'value' => 0,
			'compare' => '>',
		),
	),
) );
```

**WordPress Creates Multiple JOINs:**
```sql
-- Multiple JOINs for multiple meta conditions
SELECT wp_posts.*
FROM wp_posts
INNER JOIN wp_postmeta ON (wp_posts.ID = wp_postmeta.post_id)
INNER JOIN wp_postmeta AS mt1 ON (wp_posts.ID = mt1.post_id)
WHERE 1=1
AND wp_postmeta.meta_key = 'price'
AND CAST(wp_postmeta.meta_value AS SIGNED) >= 100
AND mt1.meta_key = 'stock'
AND CAST(mt1.meta_value AS SIGNED) > 0
```

---

## 4. Considering Alternative Storage

### When to Use Custom Tables

**Use Custom Tables For:**
- Large datasets (> 1000 rows per post)
- Complex relationships
- Frequent queries
- Need for proper indexes
- Transactional data

**Example:**
```php
// Create custom table
function create_product_specs_table() {
	global $wpdb;

	$table_name = $wpdb->prefix . 'product_specs';

	$charset_collate = $wpdb->get_charset_collate();

	$sql = "CREATE TABLE $table_name (
		id bigint(20) NOT NULL AUTO_INCREMENT,
		post_id bigint(20) NOT NULL,
		spec_name varchar(255) NOT NULL,
		spec_value text NOT NULL,
		PRIMARY KEY (id),
		KEY post_id (post_id),
		KEY spec_name (spec_name),
		KEY post_spec (post_id, spec_name)
	) $charset_collate;";

	require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );
	dbDelta( $sql );
}
register_activation_hook( __FILE__, 'create_product_specs_table' );

// Query custom table
function get_product_specs( $post_id ) {
	global $wpdb;

	return $wpdb->get_results( $wpdb->prepare(
		"SELECT spec_name, spec_value FROM {$wpdb->prefix}product_specs
		WHERE post_id = %d",
		$post_id
	) );
}
```

### When to Use Post Content

**Use Post Content For:**
- Large text content
- Searchable content
- Content that needs WordPress filters
- Rich text content

**Example:**
```php
// Store in post content
wp_update_post( array(
	'ID' => $post_id,
	'post_content' => $long_description,
) );

// Query with WordPress search
$query = new WP_Query( array(
	's' => 'search term',
) );
```

### When to Use Taxonomies

**Use Taxonomies For:**
- Categorization
- Tagging
- Hierarchical relationships
- Filtering/querying

**Example:**
```php
// Use taxonomy instead of meta
wp_set_object_terms( $post_id, array( 'featured', 'sale' ), 'product_tag' );

// Query by taxonomy
$query = new WP_Query( array(
	'tax_query' => array(
		array(
			'taxonomy' => 'product_tag',
			'field' => 'slug',
			'terms' => 'featured',
		),
	),
) );
```

---

## 5. Meta Query Performance Tips

### Cache Meta Queries

**Cache Results:**
```php
function get_posts_by_meta_cached( $meta_key, $meta_value ) {
	$cache_key = 'posts_meta_' . $meta_key . '_' . md5( serialize( $meta_value ) );
	$post_ids = wp_cache_get( $cache_key );

	if ( false === $post_ids ) {
		$query = new WP_Query( array(
			'meta_query' => array(
				array(
					'key' => $meta_key,
					'value' => $meta_value,
				),
			),
			'fields' => 'ids',
			'posts_per_page' => -1,
		) );

		$post_ids = $query->posts;
		wp_cache_set( $cache_key, $post_ids, '', 3600 );
	}

	return $post_ids;
}
```

### Prime Meta Cache

**Load Meta in Batch:**
```php
// Prime meta cache for multiple posts
update_postmeta_cache( $post_ids );

// Then get meta (no additional queries)
foreach ( $post_ids as $post_id ) {
	$meta = get_post_meta( $post_id, 'price', true );
}
```

### Use Direct Queries

**For Simple Queries:**
```php
// ✅ GOOD - Direct query for simple case
global $wpdb;

$post_ids = $wpdb->get_col( $wpdb->prepare(
	"SELECT post_id FROM {$wpdb->postmeta}
	WHERE meta_key = %s AND meta_value = %s",
	'status',
	'active'
) );
```

---

## 6. Monitoring Meta Performance

### Check Meta Table Size

**Query Table Size:**
```sql
-- Check postmeta table size
SELECT
	table_name AS 'Table',
	ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)'
FROM information_schema.TABLES
WHERE table_schema = DATABASE()
AND table_name = 'wp_postmeta';
```

### Identify Large Meta Values

**Find Large Values:**
```sql
-- Find large meta values
SELECT
	post_id,
	meta_key,
	LENGTH(meta_value) AS size
FROM wp_postmeta
ORDER BY size DESC
LIMIT 20;
```

### Monitor Meta Queries

**Use Query Monitor:**
- Shows meta query execution time
- Identifies slow meta queries
- Suggests optimizations

---

## Exam Tips

### Key Points to Remember

1. **Avoid Large Meta:**
   - Keep values small (< 1KB)
   - Don't store large text/blobs
   - Use post content for large text
   - Use custom tables for complex data

2. **Optimize Queries:**
   - Add composite indexes
   - Use specific meta keys
   - Avoid LIKE queries
   - Limit result sets

3. **Alternative Storage:**
   - Custom tables for large/complex data
   - Post content for searchable text
   - Taxonomies for categorization
   - Options API for site-wide settings

4. **Performance Tips:**
   - Cache meta query results
   - Prime meta cache
   - Use direct queries when simple
   - Monitor table size

5. **Best Practices:**
   - Limit meta keys per post
   - Use appropriate data types
   - Index frequently queried keys
   - Clean up unused meta

---

## Additional Resources

- [Custom Fields - WordPress Developer Resources](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)
- [WP_Query - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_query/)
- [Creating Tables with Plugins - WordPress Developer Resources](https://developer.wordpress.org/plugins/plugin-basics/working-with-databases/)
- Core Files:
  - `wp-includes/meta.php` - Meta functions
  - `wp-includes/class-wp-meta-query.php` - Meta query handling
