# 1.4 Transients API - Study Notes

## Overview

The Transients API provides a simple and standardised way to cache data temporarily in WordPress. Transients are similar to options but have built-in expiration times. They automatically expire after a set period, making them ideal for caching expensive operations like API calls or database queries.

**Key Reference:** [Transients API - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/transients/)

---

## 1. Create, Retrieve, and Delete Transients

### Setting Transients

**Function:** `set_transient( $transient, $value, $expiration = 0 )`

Stores a transient value with an optional expiration time. Values are automatically serialized if needed.

**Core Implementation:**
```1509:1622:wordpress/wp-includes/option.php
function set_transient( $transient, $value, $expiration = 0 ) {

	$expiration = (int) $expiration;

	/**
	 * Filters a specific transient before its value is set.
	 *
	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
	 *
	 * @since 3.0.0
	 * @since 4.2.0 The `$expiration` parameter was added.
	 * @since 4.4.0 The `$transient` parameter was added.
	 *
	 * @param mixed  $value      New value of transient.
	 * @param int    $expiration Time until expiration in seconds.
	 * @param string $transient  Transient name.
	 */
	$value = apply_filters( "pre_set_transient_{$transient}", $value, $expiration, $transient );

	/**
	 * Filters the expiration for a transient before its value is set.
	 *
	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
	 *
	 * @since 4.4.0
	 *
	 * @param int    $expiration Time until expiration in seconds. Use 0 for no expiration.
	 * @param mixed  $value      New value of transient.
	 * @param string $transient  Transient name.
	 */
	$expiration = apply_filters( "expiration_of_transient_{$transient}", $expiration, $value, $transient );

	if ( wp_using_ext_object_cache() || wp_installing() ) {
		$result = wp_cache_set( $transient, $value, 'transient', $expiration );
	} else {
		$transient_timeout = '_transient_timeout_' . $transient;
		$transient_option  = '_transient_' . $transient;
		wp_prime_option_caches( array( $transient_option, $transient_timeout ) );

		if ( false === get_option( $transient_option ) ) {
			$autoload = true;
			if ( $expiration ) {
				$autoload = false;
				add_option( $transient_timeout, time() + $expiration, '', false );
			}
			$result = add_option( $transient_option, $value, '', $autoload );
		} else {
			/*
			 * If expiration is requested, but the transient has no timeout option,
			 * delete, then re-create transient rather than update.
			 */
			$update = true;

			if ( $expiration ) {
				if ( false === get_option( $transient_timeout ) ) {
					delete_option( $transient_option );
					add_option( $transient_timeout, time() + $expiration, '', false );
					$result = add_option( $transient_option, $value, '', false );
					$update = false;
				} else {
					update_option( $transient_timeout, time() + $expiration );
				}
			}

			if ( $update ) {
				$result = update_option( $transient_option, $value );
			}
		}
	}

	if ( $result ) {

		/**
		 * Fires after the value for a specific transient has been set.
		 *
		 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
		 *
		 * @since 3.0.0
		 * @since 3.6.0 The `$value` and `$expiration` parameters were added.
		 * @since 4.4.0 The `$transient` parameter was added.
		 *
		 * @param mixed  $value      Transient value.
		 * @param int    $expiration Time until expiration in seconds.
		 * @param string $transient  The name of the transient.
		 */
		do_action( "set_transient_{$transient}", $value, $expiration, $transient );

		/**
		 * Fires after the value for a transient has been set.
		 *
		 * @since 6.8.0
		 *
		 * @param string $transient  The name of the transient.
		 * @param mixed  $value      Transient value.
		 * @param int    $expiration Time until expiration in seconds.
		 */
		do_action( 'set_transient', $transient, $value, $expiration );

		/**
		 * Fires after the transient is set.
		 *
		 * @since 3.0.0
		 * @since 3.6.0 The `$value` and `$expiration` parameters were added.
		 * @deprecated 6.8.0 Use {@see 'set_transient'} instead.
		 *
		 * @param string $transient  The name of the transient.
		 * @param mixed  $value      Transient value.
		 * @param int    $expiration Time until expiration in seconds.
		 */
		do_action_deprecated( 'setted_transient', array( $transient, $value, $expiration ), '6.8.0', 'set_transient' );
	}

	return $result;
}
```

**Important Notes:**
- Transient names must be 172 characters or fewer
- Expiration is in seconds (0 = no expiration)
- When using object cache, transients use the cache directly
- Without object cache, transients are stored as options with `_transient_` and `_transient_timeout_` prefixes

**Example:**
```php
// Cache API response for 1 hour
$api_data = get_transient( 'external_api_data' );

if ( false === $api_data ) {
	$response = wp_remote_get( 'https://api.example.com/data' );
	$api_data = json_decode( wp_remote_retrieve_body( $response ), true );

	// Cache for 1 hour (3600 seconds)
	set_transient( 'external_api_data', $api_data, HOUR_IN_SECONDS );
}
```

### Getting Transients

**Function:** `get_transient( $transient )`

Retrieves a transient value. Returns `false` if the transient doesn't exist or has expired.

**Core Implementation:**
```1431:1492:wordpress/wp-includes/option.php
function get_transient( $transient ) {

	/**
	 * Filters the value of an existing transient before it is retrieved.
	 *
	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
	 *
	 * Returning a value other than false from the filter will short-circuit retrieval
	 * and return that value instead.
	 *
	 * @since 2.8.0
	 * @since 4.4.0 The `$transient` parameter was added
	 *
	 * @param mixed  $pre_transient The default value to return if the transient does not exist.
	 *                              Any value other than false will short-circuit the retrieval
	 *                              of the transient, and return that value.
	 * @param string $transient     Transient name.
	 */
	$pre = apply_filters( "pre_transient_{$transient}", false, $transient );

	if ( false !== $pre ) {
		return $pre;
	}

	if ( wp_using_ext_object_cache() || wp_installing() ) {
		$value = wp_cache_get( $transient, 'transient' );
	} else {
		$transient_option = '_transient_' . $transient;
		if ( ! wp_installing() ) {
			// If option is not in alloptions, it is not autoloaded and thus has a timeout.
			$alloptions = wp_load_alloptions();

			if ( ! isset( $alloptions[ $transient_option ] ) ) {
				$transient_timeout = '_transient_timeout_' . $transient;
				wp_prime_option_caches( array( $transient_option, $transient_timeout ) );
				$timeout = get_option( $transient_timeout );
				if ( false !== $timeout && $timeout < time() ) {
					delete_option( $transient_option );
					delete_option( $transient_timeout );
					$value = false;
				}
			}
		}

		if ( ! isset( $value ) ) {
			$value = get_option( $transient_option );
		}
	}

	/**
	 * Filters an existing transient's value.
	 *
	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
	 *
	 * @since 2.8.0
	 * @since 4.4.0 The `$transient` parameter was added
	 *
	 * @param mixed  $value     Value of transient.
	 * @param string $transient Transient name.
	 */
	return apply_filters( "transient_{$transient}", $value, $transient );
}
```

**Example:**
```php
$cached_data = get_transient( 'my_expensive_query' );

if ( false === $cached_data ) {
	// Expensive operation
	$cached_data = get_posts( array(
		'post_type' => 'product',
		'posts_per_page' => -1,
		'meta_query' => array(
			// Complex query
		),
	) );

	set_transient( 'my_expensive_query', $cached_data, DAY_IN_SECONDS );
}
```

### Deleting Transients

**Function:** `delete_transient( $transient )`

Deletes a transient immediately, regardless of expiration time.

**Core Implementation:**
```1380:1418:wordpress/wp-includes/option.php
function delete_transient( $transient ) {

	/**
	 * Fires immediately before a specific transient is deleted.
	 *
	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.
	 *
	 * @since 3.0.0
	 *
	 * @param string $transient Transient name.
	 */
	do_action( "delete_transient_{$transient}", $transient );

	if ( wp_using_ext_object_cache() || wp_installing() ) {
		$result = wp_cache_delete( $transient, 'transient' );
	} else {
		$option_timeout = '_transient_timeout_' . $transient;
		$option         = '_transient_' . $transient;
		$result         = delete_option( $option );

		if ( $result ) {
			delete_option( $option_timeout );
		}
	}

	if ( $result ) {

		/**
		 * Fires after a transient is deleted.
		 *
		 * @since 3.0.0
		 *
		 * @param string $transient Deleted transient name.
		 */
		do_action( 'deleted_transient', $transient );
	}

	return $result;
}
```

**Example:**
```php
// Clear cache when post is updated
add_action( 'save_post', 'clear_post_cache' );
function clear_post_cache( $post_id ) {
	delete_transient( 'post_' . $post_id . '_related' );
}
```

---

## 2. Using Transients for Expensive Operations

### API Calls

Transients are ideal for caching external API responses to avoid rate limits and improve performance.

```php
function get_weather_data( $location ) {
	$transient_key = 'weather_' . md5( $location );
	$weather = get_transient( $transient_key );

	if ( false === $weather ) {
		$response = wp_remote_get(
			'https://api.weather.com/v1/current',
			array(
				'body' => array( 'location' => $location ),
				'timeout' => 15,
			)
		);

		if ( ! is_wp_error( $response ) ) {
			$weather = json_decode( wp_remote_retrieve_body( $response ), true );
			// Cache for 30 minutes
			set_transient( $transient_key, $weather, 30 * MINUTE_IN_SECONDS );
		}
	}

	return $weather;
}
```

### Database Queries

Cache expensive database queries, especially those with complex joins or aggregations.

```php
function get_popular_posts() {
	$popular = get_transient( 'popular_posts' );

	if ( false === $popular ) {
		global $wpdb;

		$popular = $wpdb->get_results(
			"SELECT p.ID, p.post_title, COUNT(c.comment_ID) as comment_count
			FROM {$wpdb->posts} p
			LEFT JOIN {$wpdb->comments} c ON p.ID = c.comment_post_ID
			WHERE p.post_status = 'publish'
			AND p.post_date > DATE_SUB(NOW(), INTERVAL 30 DAY)
			GROUP BY p.ID
			ORDER BY comment_count DESC
			LIMIT 10"
		);

		set_transient( 'popular_posts', $popular, HOUR_IN_SECONDS );
	}

	return $popular;
}
```

### Complex Calculations

Cache results of expensive calculations or data processing.

```php
function calculate_site_statistics() {
	$stats = get_transient( 'site_statistics' );

	if ( false === $stats ) {
		$stats = array(
			'total_posts' => wp_count_posts()->publish,
			'total_comments' => wp_count_comments()->approved,
			'average_post_length' => calculate_average_post_length(),
			'most_active_author' => get_most_active_author(),
		);

		// Cache for 6 hours
		set_transient( 'site_statistics', $stats, 6 * HOUR_IN_SECONDS );
	}

	return $stats;
}
```

---

## 3. Site-Wide vs Multisite Transient Storage

### Site Transients

Standard transients (`set_transient`, `get_transient`) are site-specific in multisite installations. Each site has its own transients.

```php
// Site-specific transient
set_transient( 'site_data', $data, HOUR_IN_SECONDS );
```

### Network-Wide Transients

Use `set_site_transient()` and `get_site_transient()` for network-wide caching in multisite installations. These are stored in the `wp_sitemeta` table (multisite) or `wp_options` table (single site).

**Functions:**
- `set_site_transient( $transient, $value, $expiration = 0 )`
- `get_site_transient( $transient )`
- `delete_site_transient( $transient )`

**Example:**
```php
// Network-wide transient (multisite only)
if ( is_multisite() ) {
	$network_data = get_site_transient( 'network_license_status' );

	if ( false === $network_data ) {
		$network_data = check_network_license();
		set_site_transient( 'network_license_status', $network_data, DAY_IN_SECONDS );
	}
}
```

**Storage Differences:**

**Single Site:**
- Regular transients: `wp_options` table (`_transient_*`, `_transient_timeout_*`)
- Site transients: `wp_options` table (`_site_transient_*`, `_site_transient_timeout_*`)

**Multisite:**
- Regular transients: `wp_options` table (per site)
- Site transients: `wp_sitemeta` table (network-wide)

**Core Implementation for Expired Transients:**
```1638:1687:wordpress/wp-includes/option.php
function delete_expired_transients( $force_db = false ) {
	global $wpdb;

	if ( ! $force_db && wp_using_ext_object_cache() ) {
		return;
	}

	$wpdb->query(
		$wpdb->prepare(
			"DELETE a, b FROM {$wpdb->options} a, {$wpdb->options} b
			WHERE a.option_name LIKE %s
			AND a.option_name NOT LIKE %s
			AND b.option_name = CONCAT( '_transient_timeout_', SUBSTRING( a.option_name, 12 ) )
			AND b.option_value < %d",
			$wpdb->esc_like( '_transient_' ) . '%',
			$wpdb->esc_like( '_transient_timeout_' ) . '%',
			time()
		)
	);

	if ( ! is_multisite() ) {
		// Single site stores site transients in the options table.
		$wpdb->query(
			$wpdb->prepare(
				"DELETE a, b FROM {$wpdb->options} a, {$wpdb->options} b
				WHERE a.option_name LIKE %s
				AND a.option_name NOT LIKE %s
				AND b.option_name = CONCAT( '_site_transient_timeout_', SUBSTRING( a.option_name, 17 ) )
				AND b.option_value < %d",
				$wpdb->esc_like( '_site_transient_' ) . '%',
				$wpdb->esc_like( '_site_transient_timeout_' ) . '%',
				time()
			)
		);
	} elseif ( is_main_site() && is_main_network() ) {
		// Multisite stores site transients in the sitemeta table.
		$wpdb->query(
			$wpdb->prepare(
				"DELETE a, b FROM {$wpdb->sitemeta} a, {$wpdb->sitemeta} b
				WHERE a.meta_key LIKE %s
				AND a.meta_key NOT LIKE %s
				AND b.meta_key = CONCAT( '_site_transient_timeout_', SUBSTRING( a.meta_key, 17 ) )
				AND b.meta_value < %d",
				$wpdb->esc_like( '_site_transient_' ) . '%',
				$wpdb->esc_like( '_site_transient_timeout_' ) . '%',
				time()
			)
		);
	}
}
```

---

## 4. Transient Expiration and Cache Invalidation

### Expiration Times

Use WordPress time constants for readability:

```php
// WordPress time constants
MINUTE_IN_SECONDS = 60
HOUR_IN_SECONDS = 3600
DAY_IN_SECONDS = 86400
WEEK_IN_SECONDS = 604800
MONTH_IN_SECONDS = 2592000
YEAR_IN_SECONDS = 31536000

// Examples
set_transient( 'short_cache', $data, 5 * MINUTE_IN_SECONDS );
set_transient( 'medium_cache', $data, HOUR_IN_SECONDS );
set_transient( 'long_cache', $data, DAY_IN_SECONDS );
```

### Manual Cache Invalidation

Delete transients when related data changes:

```php
// Invalidate cache on post save
add_action( 'save_post', 'invalidate_post_cache' );
function invalidate_post_cache( $post_id ) {
	$post_type = get_post_type( $post_id );

	// Delete specific post cache
	delete_transient( 'post_' . $post_id );

	// Delete archive cache
	delete_transient( 'archive_' . $post_type );

	// Delete related posts cache
	delete_transient( 'related_posts_' . $post_id );
}

// Invalidate cache on option update
add_action( 'update_option', 'invalidate_settings_cache', 10, 2 );
function invalidate_settings_cache( $option_name, $old_value ) {
	if ( 'my_plugin_settings' === $option_name ) {
		delete_transient( 'processed_settings' );
	}
}
```

### Transient Expiration Behaviour

**Without Object Cache:**
- Expired transients are checked on retrieval
- `get_transient()` automatically deletes expired transients
- Expired transients may accumulate until manually cleaned

**With Object Cache (Redis/Memcached):**
- Expiration is handled by the cache backend
- No database queries for expired transients
- Automatic cleanup by cache system

**Best Practice:** Always check for `false` when retrieving transients:

```php
$data = get_transient( 'my_data' );

// ✅ GOOD - Explicit false check
if ( false === $data ) {
	// Regenerate data
}

// ❌ BAD - May fail if transient stores boolean false
if ( ! $data ) {
	// This won't work if $data is actually false
}
```

### Batch Cache Invalidation

Use transients with versioning for easier batch invalidation:

```php
function get_cached_data( $key ) {
	$version = get_transient( 'cache_version' );
	if ( false === $version ) {
		$version = time();
		set_transient( 'cache_version', $version, YEAR_IN_SECONDS );
	}

	$full_key = $key . '_v' . $version;
	return get_transient( $full_key );
}

function invalidate_all_caches() {
	// Update version to invalidate all caches
	set_transient( 'cache_version', time(), YEAR_IN_SECONDS );
}
```

---

## Performance Best Practices

### 1. Use Appropriate Expiration Times

```php
// ✅ GOOD - Short expiration for frequently changing data
set_transient( 'current_user_posts', $posts, 5 * MINUTE_IN_SECONDS );

// ✅ GOOD - Long expiration for stable data
set_transient( 'site_config', $config, WEEK_IN_SECONDS );

// ❌ BAD - Too long for dynamic content
set_transient( 'user_posts', $posts, YEAR_IN_SECONDS );
```

### 2. Avoid Transient Name Collisions

Use unique prefixes to avoid conflicts:

```php
// ✅ GOOD - Unique prefix
set_transient( 'my_plugin_api_data', $data, HOUR_IN_SECONDS );

// ❌ BAD - Generic name, may conflict
set_transient( 'api_data', $data, HOUR_IN_SECONDS );
```

### 3. Handle Cache Misses Gracefully

```php
function get_cached_data() {
	$data = get_transient( 'my_data' );

	if ( false === $data ) {
		// Generate data
		$data = expensive_operation();

		// Only cache if operation succeeded
		if ( ! is_wp_error( $data ) && ! empty( $data ) ) {
			set_transient( 'my_data', $data, HOUR_IN_SECONDS );
		}
	}

	return $data;
}
```

### 4. Consider Object Cache Availability

```php
function cache_data( $key, $data, $expiration ) {
	// Object cache handles expiration automatically
	if ( wp_using_ext_object_cache() ) {
		set_transient( $key, $data, $expiration );
	} else {
		// Without object cache, consider shorter expiration
		// to avoid database bloat
		set_transient( $key, $data, min( $expiration, HOUR_IN_SECONDS ) );
	}
}
```

---

## Exam Tips

### Key Points to Remember

1. **Transient Storage:**
   - With object cache: Uses cache directly
   - Without object cache: Stored as options with `_transient_` prefix
   - Site transients: Network-wide in multisite

2. **Expiration:**
   - Expiration is in seconds (0 = no expiration)
   - Use WordPress time constants for readability
   - Expired transients return `false`

3. **Best Practices:**
   - Always check for `false === $value` (not just `!$value`)
   - Use unique transient names with prefixes
   - Invalidate caches when source data changes
   - Consider expiration times based on data volatility

4. **Common Mistakes:**
   - Forgetting to check for `false` explicitly
   - Using too long expiration times
   - Not invalidating caches on data updates
   - Generic transient names causing conflicts

---

## Additional Resources

- [Transients API - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/transients/)
- [WordPress Time Constants](https://developer.wordpress.org/reference/functions/wp_get_schedules/#description)
- Core Files:
  - `wp-includes/option.php` - Transient functions implementation
