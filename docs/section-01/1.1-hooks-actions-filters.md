---
title: 1.1 Hooks (Actions and Filters) - Study Notes
---

# 1.1 Hooks (Actions and Filters) - Study Notes

## Overview

WordPress hooks allow plugins and themes to extend or modify WordPress behaviour without modifying core files. Understanding when and how to use hooks is fundamental to WordPress development.

**Key Reference:** [Plugin API - WordPress Developer Resources](https://developer.wordpress.org/plugins/hooks/)

---

## 1. Differentiating Actions and Filters

### Actions (Side Effects)

**Purpose:** Execute code at specific points in WordPress execution. Actions do not return values; they perform side effects.

**Characteristics:**
- Use `add_action()` to hook into actions
- Use `do_action()` to fire actions
- Callbacks do not return values (or return values are ignored)
- Used for: logging, sending emails, enqueuing assets, modifying global state

**Core Implementation:**
```446:448:wordpress/wp-includes/plugin.php
function add_action( $hook_name, $callback, $priority = 10, $accepted_args = 1 ) {
	return add_filter( $hook_name, $callback, $priority, $accepted_args );
}
```

**Example - Action Hook:**
```php
// Hook into post save
add_action( 'save_post', 'my_custom_save_handler', 10, 2 );

function my_custom_save_handler( $post_id, $post ) {
	// Perform side effect: log or send notification
	error_log( "Post {$post_id} was saved" );
	// No return value needed
}
```

### Filters (Data Transformation)

**Purpose:** Modify data before it is used. Filters must return a value.

**Characteristics:**
- Use `add_filter()` to hook into filters
- Use `apply_filters()` to apply filters
- Callbacks **must** return a value (the modified data)
- Used for: modifying content, changing query arguments, altering output

**Core Implementation:**
```173:210:wordpress/wp-includes/plugin.php
function apply_filters( $hook_name, $value, ...$args ) {
	global $wp_filter, $wp_filters, $wp_current_filter;

	if ( ! isset( $wp_filters[ $hook_name ] ) ) {
		$wp_filters[ $hook_name ] = 1;
	} else {
		++$wp_filters[ $hook_name ];
	}

	// Do 'all' actions first.
	if ( isset( $wp_filter['all'] ) ) {
		$wp_current_filter[] = $hook_name;

		$all_args = func_get_args(); // phpcs:ignore PHPCompatibility.FunctionUse.ArgumentFunctionsReportCurrentValue.NeedsInspection
		_wp_call_all_hook( $all_args );
	}

	if ( ! isset( $wp_filter[ $hook_name ] ) ) {
		if ( isset( $wp_filter['all'] ) ) {
			array_pop( $wp_current_filter );
		}

		return $value;
	}

	if ( ! isset( $wp_filter['all'] ) ) {
		$wp_current_filter[] = $hook_name;
	}

	// Pass the value to WP_Hook.
	array_unshift( $args, $value );

	$filtered = $wp_filter[ $hook_name ]->apply_filters( $value, $args );

	array_pop( $wp_current_filter );

	return $filtered;
}
```

**Example - Filter Hook:**
```php
// Modify post content
add_filter( 'the_content', 'my_content_modifier' );

function my_content_modifier( $content ) {
	// Must return the modified value
	return $content . '<p>Custom footer text</p>';
}
```

### Key Difference Summary

| Aspect | Actions | Filters |
|--------|---------|---------|
| **Return Value** | Ignored | Required |
| **Purpose** | Side effects | Data transformation |
| **Function** | `do_action()` | `apply_filters()` |
| **Hook Function** | `add_action()` | `add_filter()` |
| **Underlying Mechanism** | Actions are filters with `doing_action = true` | Direct filter application |

**Important:** Internally, actions are implemented as filters. See:

```363:371:wordpress/wp-includes/class-wp-hook.php
	public function do_action( $args ) {
		$this->doing_action = true;
		$this->apply_filters( '', $args );

		// If there are recursive calls to the current action, we haven't finished it until we get to the last one.
		if ( ! $this->nesting_level ) {
			$this->doing_action = false;
		}
	}
```

---

## 2. Important Core Hooks

### Common Action Hooks

#### Initialization Hooks
- **`init`** - Fires after WordPress has finished loading but before headers are sent. Good for registering post types, taxonomies, and early custom functionality.
- **`wp_loaded`** - Fires after WordPress is fully loaded. All core functions are available.
- **`admin_init`** - Fires in admin area after admin is initialized. Use for admin-only functionality.
- **`wp_enqueue_scripts`** - Fires when scripts and styles are enqueued. Use to enqueue front-end assets.
- **`admin_enqueue_scripts`** - Fires when admin scripts/styles are enqueued. Use for admin assets.

#### Content Lifecycle Hooks
- **`save_post`** - Fires when a post is saved (create or update). Parameters: `$post_id`, `$post`, `$update`.
- **`delete_post`** - Fires immediately before a post is deleted.
- **`transition_post_status`** - Fires when post status changes. Parameters: `$new_status`, `$old_status`, `$post`.

#### Template Hooks
- **`wp_head`** - Fires in `<head>` section. Use for meta tags, analytics.
- **`wp_footer`** - Fires before closing `</body>` tag.
- **`wp_body_open`** - Fires immediately after opening `<body>` tag (WP 5.2+).

#### User/Auth Hooks
- **`wp_login`** - Fires after user logs in. Parameters: `$user_login`, `$user`.
- **`wp_logout`** - Fires after user logs out.
- **`user_register`** - Fires immediately after a new user is registered.

### Common Filter Hooks

#### Content Filters
- **`the_content`** - Filters post content before display. Most common content filter.
- **`the_title`** - Filters post title. Parameters: `$title`, `$post_id`.
- **`the_excerpt`** - Filters post excerpt.
- **`wp_trim_excerpt`** - Filters excerpt length and text.

#### Query Filters
- **`posts_clauses`** - Filters all query clauses (WHERE, JOIN, etc.). Advanced query modification.
- **`posts_where`** - Filters WHERE clause.
- **`posts_join`** - Filters JOIN clause.
- **`posts_orderby`** - Filters ORDER BY clause.
- **`posts_request`** - Filters the complete SQL query string.

#### Meta/Data Filters
- **`get_post_metadata`** - Filters post meta value before retrieval.
- **`update_post_metadata`** - Filters post meta value before update.
- **`sanitize_file_name`** - Filters filename during upload.

#### URL/Path Filters
- **`upload_dir`** - Filters upload directory path and URL.
- **`site_url`** - Filters site URL.
- **`home_url`** - Filters home URL.

### Dynamic Hooks

WordPress creates dynamic hooks based on context:

```php
// Dynamic action hooks
do_action( "registered_post_type_{$post_type}", $post_type, $post_type_object );
do_action( "save_post_{$post_type}", $post_id, $post );

// Dynamic filter hooks
apply_filters( "post_type_labels_{$post_type}", $labels );
apply_filters( "edit_{$field}", $value, $post_id );
```

**Example Usage:**
```php
// Hook only for 'product' post type saves
add_action( 'save_post_product', 'handle_product_save', 10, 2 );

// Modify labels only for 'event' post type
add_filter( 'post_type_labels_event', 'custom_event_labels' );
```

**Reference:** [Action Reference - WordPress Codex](https://codex.wordpress.org/Plugin_API/Action_Reference) | [Filter Reference - WordPress Codex](https://codex.wordpress.org/Plugin_API/Filter_Reference)

---

## 3. Writing Efficient Custom Hooks

### Creating Custom Actions

```php
// Fire a custom action
do_action( 'my_plugin_before_process', $data, $user_id );

// Others can hook into it
add_action( 'my_plugin_before_process', 'third_party_handler', 10, 2 );
```

### Creating Custom Filters

```php
// Apply a custom filter
$output = apply_filters( 'my_plugin_output', $default_output, $context );

// Others can modify it
add_filter( 'my_plugin_output', 'modify_output', 10, 2 );
```

### Performance Best Practices

#### 1. Avoid Hooking into 'all' Hook

The `'all'` hook fires for every single hook execution. Use sparingly and only for debugging:

```php
// ❌ BAD - Fires on every hook, very expensive
add_action( 'all', 'my_debug_handler' );

// ✅ GOOD - Hook to specific hooks
add_action( 'save_post', 'my_save_handler' );
```

#### 2. Use Appropriate Priorities

Default priority is 10. Use lower numbers for earlier execution, higher for later:

```php
// Execute early (before most plugins)
add_action( 'init', 'early_init_handler', 1 );

// Execute late (after most plugins)
add_action( 'init', 'late_init_handler', 99 );
```

#### 3. Specify Correct `$accepted_args`

Only accept the arguments you need to reduce overhead:

```php
// ❌ BAD - Accepts all 3 args even though only using 1
add_action( 'save_post', 'my_handler' ); // Default accepts 1

// ✅ GOOD - Specify exactly what you need
add_action( 'save_post', 'my_handler', 10, 2 ); // Accepts 2 args
```

**Core Implementation Note:**
```332:344:wordpress/wp-includes/class-wp-hook.php
			foreach ( $this->callbacks[ $priority ] as $the_ ) {
				if ( ! $this->doing_action ) {
					$args[0] = $value;
				}

				// Avoid the array_slice() if possible.
				if ( 0 === $the_['accepted_args'] ) {
					$value = call_user_func( $the_['function'] );
				} elseif ( $the_['accepted_args'] >= $num_args ) {
					$value = call_user_func_array( $the_['function'], $args );
				} else {
					$value = call_user_func_array( $the_['function'], array_slice( $args, 0, $the_['accepted_args'] ) );
				}
			}
```

#### 4. Conditional Hook Execution

Only hook when necessary:

```php
// ✅ GOOD - Only hook in admin
if ( is_admin() ) {
	add_action( 'admin_init', 'admin_only_handler' );
}

// ✅ GOOD - Only hook for specific post types
add_action( 'save_post', 'my_handler' );
function my_handler( $post_id ) {
	if ( 'product' !== get_post_type( $post_id ) ) {
		return;
	}
	// Process product
}
```

#### 5. Cache Expensive Operations

If your hook performs expensive operations, cache results:

```php
add_filter( 'the_content', 'expensive_content_filter' );

function expensive_content_filter( $content ) {
	$cache_key = 'content_' . md5( $content );
	$cached = wp_cache_get( $cache_key );

	if ( false !== $cached ) {
		return $cached;
	}

	// Expensive operation
	$modified = do_expensive_processing( $content );
	wp_cache_set( $cache_key, $modified, '', 3600 );

	return $modified;
}
```

#### 6. Avoid Unbounded Queries in Hooks

```php
// ❌ BAD - Unbounded query on every page load
add_action( 'wp_head', 'bad_handler' );
function bad_handler() {
	$posts = get_posts(); // No limit!
	foreach ( $posts as $post ) {
		// Process
	}
}

// ✅ GOOD - Limit queries
add_action( 'wp_head', 'good_handler' );
function good_handler() {
	$posts = get_posts( array( 'numberposts' => 10 ) );
	foreach ( $posts as $post ) {
		// Process
	}
}
```

**Reference:** [Plugin API - Performance Best Practices](https://developer.wordpress.org/plugins/plugin-basics/best-practices/#performance)

---

## 4. Debugging Hook Priorities and Conflicts

### Understanding Priority Execution

Hooks execute in priority order (lower numbers first). Callbacks with the same priority execute in the order they were added.

**Core Implementation:**
```82:106:wordpress/wp-includes/class-wp-hook.php
	public function add_filter( $hook_name, $callback, $priority, $accepted_args ) {
		if ( null === $priority ) {
			$priority = 0;
		}

		$idx = _wp_filter_build_unique_id( $hook_name, $callback, $priority );

		$priority_existed = isset( $this->callbacks[ $priority ] );

		$this->callbacks[ $priority ][ $idx ] = array(
			'function'      => $callback,
			'accepted_args' => (int) $accepted_args,
		);

		// If we're adding a new priority to the list, put them back in sorted order.
		if ( ! $priority_existed && count( $this->callbacks ) > 1 ) {
			ksort( $this->callbacks, SORT_NUMERIC );
		}

		$this->priorities = array_keys( $this->callbacks );

		if ( $this->nesting_level > 0 ) {
			$this->resort_active_iterations( $priority, $priority_existed );
		}
	}
```

**Execution Order Example:**
```php
// Execution order: 1, 5, 10 (first), 10 (second), 20
add_action( 'init', 'handler_1', 1 );
add_action( 'init', 'handler_2', 20 );
add_action( 'init', 'handler_3', 10 );
add_action( 'init', 'handler_4', 5 );
add_action( 'init', 'handler_5', 10 ); // Same priority as handler_3, but added later
```

### Debugging Tools

#### 1. Check if Hook is Registered

```php
// Check if any callbacks exist
if ( has_action( 'my_hook' ) ) {
	// Hook has callbacks
}

// Check specific callback
if ( has_action( 'my_hook', 'my_callback_function' ) ) {
	// Callback is registered
}

// Get priority of specific callback
$priority = has_action( 'my_hook', 'my_callback_function' );
if ( false !== $priority ) {
	echo "Callback registered at priority: {$priority}";
}
```

**Core Implementation:**
```240:262:wordpress/wp-includes/class-wp-hook.php
	public function has_filter( $hook_name = '', $callback = false, $priority = false ) {
		if ( false === $callback ) {
			return $this->has_filters();
		}

		$function_key = _wp_filter_build_unique_id( $hook_name, $callback, false );

		if ( ! $function_key ) {
			return false;
		}

		if ( is_int( $priority ) ) {
			return isset( $this->callbacks[ $priority ][ $function_key ] );
		}

		foreach ( $this->callbacks as $callback_priority => $callbacks ) {
			if ( isset( $callbacks[ $function_key ] ) ) {
				return $callback_priority;
			}
		}

		return false;
	}
```

#### 2. Inspect Hook Callbacks

```php
global $wp_filter;

if ( isset( $wp_filter['my_hook'] ) ) {
	$hook = $wp_filter['my_hook'];

	// Get all priorities
	$priorities = $hook->priorities;

	// Get all callbacks
	$callbacks = $hook->callbacks;

	foreach ( $callbacks as $priority => $callback_group ) {
		foreach ( $callback_group as $callback_id => $callback_data ) {
			echo "Priority: {$priority}, Callback: ";
			print_r( $callback_data['function'] );
		}
	}
}
```

#### 3. Use Query Monitor Plugin

Query Monitor shows:
- All hooks fired on a page
- Callbacks registered to each hook
- Execution order and priorities
- Execution time for each callback

#### 4. Debug Current Hook Stack

```php
// Check current hook being executed
global $wp_current_filter;
$current_hook = end( $wp_current_filter );

// Check if we're inside a specific hook
if ( doing_action( 'save_post' ) ) {
	// We're inside save_post action
}

// Check how many times a filter has been applied
$count = did_filter( 'the_content' );
```

**Core Functions:**
```php
// Check if action is currently executing
function doing_action( $hook_name = null );

// Check if filter is currently executing
function doing_filter( $hook_name = null );

// Get count of how many times filter was applied
function did_filter( $hook_name );
```

#### 5. Remove Hooks for Testing

```php
// Temporarily remove a hook to test
remove_action( 'save_post', 'problematic_callback', 10 );

// Test your code

// Re-add if needed
add_action( 'save_post', 'problematic_callback', 10 );
```

**Core Implementation:**
```193:217:wordpress/wp-includes/class-wp-hook.php
	public function remove_filter( $hook_name, $callback, $priority ) {
		if ( null === $priority ) {
			$priority = 0;
		}

		$function_key = _wp_filter_build_unique_id( $hook_name, $callback, $priority );

		$exists = isset( $function_key, $this->callbacks[ $priority ][ $function_key ] );

		if ( $exists ) {
			unset( $this->callbacks[ $priority ][ $function_key ] );

			if ( ! $this->callbacks[ $priority ] ) {
				unset( $this->callbacks[ $priority ] );

				$this->priorities = array_keys( $this->callbacks );

				if ( $this->nesting_level > 0 ) {
					$this->resort_active_iterations();
				}
			}
		}

		return $exists;
	}
```

**Important:** When removing, you must specify the exact priority used when adding:

```php
// Added with priority 10
add_action( 'init', 'my_handler', 10 );

// ❌ Won't work - priority mismatch
remove_action( 'init', 'my_handler', 5 );

// ✅ Works - exact priority match
remove_action( 'init', 'my_handler', 10 );
```

#### 6. Debug Hook Conflicts

**Common Conflict Scenarios:**

1. **Priority Conflicts:** Two plugins modify the same data in wrong order
   ```php
   // Plugin A (priority 10) - adds content
   add_filter( 'the_content', 'plugin_a_handler', 10 );

   // Plugin B (priority 10) - expects content to exist
   add_filter( 'the_content', 'plugin_b_handler', 10 );

   // Solution: Adjust priorities
   add_filter( 'the_content', 'plugin_b_handler', 15 ); // Run after Plugin A
   ```

2. **Missing Return Values in Filters:**
   ```php
   // ❌ BAD - Forgets to return value
   add_filter( 'the_content', 'bad_filter' );
   function bad_filter( $content ) {
   	$content .= 'Additional text';
   	// Missing return!
   }

   // ✅ GOOD - Returns modified value
   add_filter( 'the_content', 'good_filter' );
   function good_filter( $content ) {
   	return $content . 'Additional text';
   }
   ```

3. **Hook Not Firing:**
   ```php
   // Check if hook exists
   if ( ! has_action( 'my_custom_hook' ) ) {
   	error_log( 'Hook not registered' );
   }

   // Verify hook fires
   add_action( 'my_custom_hook', function() {
   	error_log( 'Hook fired!' );
   } );
   ```

### Best Practices for Avoiding Conflicts

1. **Use Descriptive Hook Names:** Include plugin/theme prefix
   ```php
   // ✅ GOOD
   do_action( 'my_plugin_before_save', $data );

   // ❌ BAD - Too generic
   do_action( 'before_save', $data );
   ```

2. **Document Expected Priorities:** If your hook expects certain execution order, document it
   ```php
   /**
    * Fires before processing data.
    *
    * Use priority < 10 to run before default processing.
    * Use priority > 10 to run after default processing.
    */
   do_action( 'my_plugin_process', $data );
   ```

3. **Use Conditional Logic:** Check state before modifying
   ```php
   add_filter( 'the_content', 'conditional_modifier' );
   function conditional_modifier( $content ) {
   	// Only modify if not already modified
   	if ( strpos( $content, 'my_marker' ) !== false ) {
   		return $content;
   	}
   	return $content . 'my_marker';
   }
   ```

**Reference:** [Debugging in WordPress - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/debug/debug-wordpress/)

---

## Exam Tips

### Key Points to Remember

1. **Actions vs Filters:**
   - Actions = side effects, no return value
   - Filters = data transformation, must return value
   - Internally, actions are filters with `doing_action = true`

2. **Priority Execution:**
   - Lower numbers execute first
   - Same priority = order of registration
   - Default priority is 10

3. **Performance:**
   - Avoid `'all'` hook in production
   - Specify correct `$accepted_args`
   - Use conditional hooking
   - Cache expensive operations

4. **Debugging:**
   - Use `has_action()` / `has_filter()` to check registration
   - Use `doing_action()` / `doing_filter()` to check current execution
   - Use Query Monitor for visual inspection
   - Remove hooks temporarily to isolate issues

5. **Common Mistakes:**
   - Forgetting to return value in filters
   - Wrong priority when removing hooks
   - Unbounded queries in hooks
   - Hooking into expensive hooks unnecessarily

---

## Additional Resources

- [Plugin API - WordPress Developer Resources](https://developer.wordpress.org/plugins/hooks/)
- [Action Reference - WordPress Codex](https://codex.wordpress.org/Plugin_API/Action_Reference)
- [Filter Reference - WordPress Codex](https://codex.wordpress.org/Plugin_API/Filter_Reference)
- [Hooks - WordPress Codex](https://codex.wordpress.org/Plugin_API/Hooks)
- [Query Monitor Plugin](https://wordpress.org/plugins/query-monitor/) - Essential debugging tool
- Core Files:
  - `wp-includes/plugin.php` - Main hook functions
  - `wp-includes/class-wp-hook.php` - WP_Hook class implementation
