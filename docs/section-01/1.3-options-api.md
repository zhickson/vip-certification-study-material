# 1.3 Options API - Study Notes

## Overview

The Options API provides a standardised way to store and retrieve site-wide settings in WordPress. Options are stored in the `wp_options` database table and can be autoloaded (loaded on every page request) or non-autoloaded (loaded only when explicitly requested). Understanding how to efficiently use the Options API is crucial for performance, especially in enterprise environments.

**Key Reference:** [Options API - WordPress Developer Resources](https://developer.wordpress.org/plugins/settings/options-api/)

---

## 1. Get, Set and Delete Options Correctly

### Getting Options

**Function:** `get_option( $option, $default_value = false )`

Retrieves an option value from the database. Returns `false` if the option doesn't exist and no default is provided.

**Core Implementation:**
```78:256:wordpress/wp-includes/option.php
function get_option( $option, $default_value = false ) {
	global $wpdb;

	if ( is_scalar( $option ) ) {
		$option = trim( $option );
	}

	if ( empty( $option ) ) {
		return false;
	}

	/*
	 * Until a proper _deprecated_option() function can be introduced,
	 * redirect requests to deprecated keys to the new, correct ones.
	 */
	$deprecated_keys = array(
		'blacklist_keys'    => 'disallowed_keys',
		'comment_whitelist' => 'comment_previously_approved',
	);

	if ( isset( $deprecated_keys[ $option ] ) && ! wp_installing() ) {
		_deprecated_argument(
			__FUNCTION__,
			'5.5.0',
			sprintf(
				/* translators: 1: Deprecated option key, 2: New option key. */
				__( 'The "%1$s" option key has been renamed to "%2$s".' ),
				$option,
				$deprecated_keys[ $option ]
			)
		);
		return get_option( $deprecated_keys[ $option ], $default_value );
	}

	/**
	 * Filters the value of an existing option before it is retrieved.
	 *
	 * The dynamic portion of the hook name, `$option`, refers to the option name.
	 *
	 * Returning a value other than false from the filter will short-circuit retrieval
	 * and return that value instead.
	 *
	 * @since 1.5.0
	 * @since 4.4.0 The `$option` parameter was added.
	 * @since 4.9.0 The `$default_value` parameter was added.
	 *
	 * @param mixed  $pre_option    The value to return instead of the option value. This differs from
	 *                              `$default_value`, which is used as the fallback value in the event
	 *                              the option doesn't exist elsewhere in get_option().
	 *                              Default false (to skip past the short-circuit).
	 * @param string $option        Option name.
	 * @param mixed  $default_value The fallback value to return if the option does not exist.
	 *                              Default false.
	 */
	$pre = apply_filters( "pre_option_{$option}", false, $option, $default_value );

	/**
	 * Filters the value of any existing option before it is retrieved.
	 *
	 * The dynamic portion of the hook name, `$option`, refers to the option name.
	 *
	 * Returning a value other than false from the filter will short-circuit retrieval
	 * and return that value instead.
	 *
	 * @since 1.5.0
	 * @since 4.4.0 The `$option` parameter was added.
	 * @since 4.9.0 The `$default_value` parameter was added.
	 *
	 * @param mixed  $pre_option    The value to return instead of the option value. This differs from
	 *                              `$default_value`, which is used as the fallback value in the event
	 *                              the option doesn't exist elsewhere in get_option().
	 *                              Default false (to skip past the short-circuit).
	 * @param string $option        Option name.
	 * @param mixed  $default_value The fallback value to return if the option does not exist.
	 *                              Default false.
	 */
	$pre = apply_filters( 'pre_option', $pre, $option, $default_value );

	if ( false !== $pre ) {
		return $pre;
	}

	if ( wp_installing() ) {
		$suppress = $wpdb->suppress_errors();
	}

	$passed_default = func_num_args() > 1;

	if ( ! wp_installing() ) {
		$alloptions = wp_load_alloptions();
		/*
		 * When getting an option value, we check in the following order for performance:
		 *
		 * 1. Check the 'alloptions' cache first to prioritize existing loaded options.
		 * 2. Check the 'notoptions' cache before a cache lookup or DB hit.
		 * 3. Check the 'options' cache prior to a DB hit.
		 * 4. Check the DB for the option and cache it in either the 'options' or 'notoptions' cache.
		 */
		if ( isset( $alloptions[ $option ] ) ) {
			$value = $alloptions[ $option ];
		} else {
			// Check for non-existent options first to avoid unnecessary object cache lookups and DB hits.
			$notoptions = wp_cache_get( 'notoptions', 'options' );

			if ( ! is_array( $notoptions ) ) {
				$notoptions = array();
				wp_cache_set( 'notoptions', $notoptions, 'options' );
			}

			if ( isset( $notoptions[ $option ] ) ) {
				/**
				 * Filters the default value for an option.
				 *
				 * The dynamic portion of the hook name, `$option`, refers to the option name.
				 *
				 * @since 3.4.0
				 * @since 4.4.0 The `$option` parameter was added.
				 * @since 4.7.0 The `$passed_default` parameter was added to distinguish between a `false` value and the default parameter value.
				 *
				 * @param mixed  $default_value  The default value to return if the option does not exist
				 *                               in the database.
				 * @param string $option         Option name.
				 * @param bool   $passed_default Was `get_option()` passed a default value?
				 */
				return apply_filters( "default_option_{$option}", $default_value, $option, $passed_default );
			}

			$value = wp_cache_get( $option, 'options' );

			if ( false === $value ) {

				$row = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", $option ) );

				// Has to be get_row() instead of get_var() because of funkiness with 0, false, null values.
				if ( is_object( $row ) ) {
					$value = $row->option_value;
					wp_cache_add( $option, $value, 'options' );
				} else { // Option does not exist, so we must cache its non-existence.
					$notoptions[ $option ] = true;
					wp_cache_set( 'notoptions', $notoptions, 'options' );

					/** This filter is documented in wp-includes/option.php */
					return apply_filters( "default_option_{$option}", $default_value, $option, $passed_default );
				}
			}
		}
	} else {
		$suppress = $wpdb->suppress_errors();
		$row      = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", $option ) );
		$wpdb->suppress_errors( $suppress );

		if ( is_object( $row ) ) {
			$value = $row->option_value;
		} else {
			/** This filter is documented in wp-includes/option.php */
			return apply_filters( "default_option_{$option}", $default_value, $option, $passed_default );
		}
	}

	// If home is not set, use siteurl.
	if ( 'home' === $option && '' === $value ) {
		return get_option( 'siteurl' );
	}

	if ( in_array( $option, array( 'siteurl', 'home', 'category_base', 'tag_base' ), true ) ) {
		$value = untrailingslashit( $value );
	}

	/**
	 * Filters the value of an existing option.
	 *
	 * The dynamic portion of the hook name, `$option`, refers to the option name.
	 *
	 * @since 1.5.0 As 'option_' . $setting
	 * @since 3.0.0
	 * @since 4.4.0 The `$option` parameter was added.
	 *
	 * @param mixed  $value  Value of the option. If stored serialized, it will be
	 *                       unserialized prior to being returned.
	 * @param string $option Option name.
	 */
	return apply_filters( "option_{$option}", maybe_unserialize( $value ), $option );
}
```

**Key Points:**
- Options are automatically unserialized when retrieved
- The function checks multiple cache layers before hitting the database
- Returns `false` if option doesn't exist and no default is provided
- Always provide a default value to avoid confusion between "option doesn't exist" and "option value is false"

**Example - Basic Usage:**
```php
// Get an option with a default value
$site_name = get_option( 'my_plugin_site_name', 'Default Site Name' );

// Get an option without default (returns false if not set)
$setting = get_option( 'my_plugin_setting' );
if ( false === $setting ) {
	// Option doesn't exist, initialise it
	add_option( 'my_plugin_setting', 'default_value' );
}

// Get multiple options efficiently
$options = get_options( array( 'option1', 'option2', 'option3' ) );
```

**Example - Using Filters:**
```php
// Filter a specific option before retrieval
add_filter( 'pre_option_my_plugin_setting', function( $pre, $option, $default ) {
	// Short-circuit retrieval and return custom value
	return 'custom_value';
}, 10, 3 );

// Filter any option before retrieval
add_filter( 'pre_option', function( $pre, $option, $default ) {
	if ( 'my_plugin_' === substr( $option, 0, 11 ) ) {
		// Custom logic for all plugin options
	}
	return $pre;
}, 10, 3 );

// Filter option value after retrieval
add_filter( 'option_my_plugin_setting', function( $value, $option ) {
	// Modify the retrieved value
	return strtoupper( $value );
}, 10, 2 );
```

### Setting Options

**Function:** `update_option( $option, $value, $autoload = null )`

Updates an existing option or creates it if it doesn't exist. Automatically serializes non-scalar values.

**Core Implementation:**
```847:1034:wordpress/wp-includes/option.php
function update_option( $option, $value, $autoload = null ) {
	global $wpdb;

	if ( is_scalar( $option ) ) {
		$option = trim( $option );
	}

	if ( empty( $option ) ) {
		return false;
	}

	/*
	 * Until a proper _deprecated_option() function can be introduced,
	 * redirect requests to deprecated keys to the new, correct ones.
	 */
	$deprecated_keys = array(
		'blacklist_keys'    => 'disallowed_keys',
		'comment_whitelist' => 'comment_previously_approved',
	);

	if ( isset( $deprecated_keys[ $option ] ) && ! wp_installing() ) {
		_deprecated_argument(
			__FUNCTION__,
			'5.5.0',
			sprintf(
				/* translators: 1: Deprecated option key, 2: New option key. */
				__( 'The "%1$s" option key has been renamed to "%2$s".' ),
				$option,
				$deprecated_keys[ $option ]
			)
		);
		return update_option( $deprecated_keys[ $option ], $value, $autoload );
	}

	wp_protect_special_option( $option );

	if ( is_object( $value ) ) {
		$value = clone $value;
	}

	$value     = sanitize_option( $option, $value );
	$old_value = get_option( $option );

	/**
	 * Filters a specific option before its value is (maybe) serialized and updated.
	 *
	 * The dynamic portion of the hook name, `$option`, refers to the option name.
	 *
	 * @since 2.6.0
	 * @since 4.4.0 The `$option` parameter was added.
	 *
	 * @param mixed  $value     The new, unserialized option value.
	 * @param mixed  $old_value The old option value.
	 * @param string $option    Option name.
	 */
	$value = apply_filters( "pre_update_option_{$option}", $value, $old_value, $option );

	/**
	 * Filters an option before its value is (maybe) serialized and updated.
	 *
	 * @since 3.9.0
	 *
	 * @param mixed  $value     The new, unserialized option value.
	 * @param string $option    Name of the option.
	 * @param mixed  $old_value The old option value.
	 */
	$value = apply_filters( 'pre_update_option', $value, $option, $old_value );

	/*
	 * If the new and old values are the same, no need to update.
	 *
	 * Unserialized values will be adequate in most cases. If the unserialized
	 * data differs, the (maybe) serialized data is checked to avoid
	 * unnecessary database calls for otherwise identical object instances.
	 *
	 * See https://core.trac.wordpress.org/ticket/38903
	 */
	if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) {
		return false;
	}

	/** This filter is documented in wp-includes/option.php */
	if ( apply_filters( "default_option_{$option}", false, $option, false ) === $old_value ) {
		return add_option( $option, $value, '', $autoload );
	}

	$serialized_value = maybe_serialize( $value );

	/**
	 * Fires immediately before an option value is updated.
	 *
	 * @since 2.9.0
	 *
	 * @param string $option    Name of the option to update.
	 * @param mixed  $old_value The old option value.
	 * @param mixed  $value     The new option value.
	 */
	do_action( 'update_option', $option, $old_value, $value );

	$update_args = array(
		'option_value' => $serialized_value,
	);

	if ( null !== $autoload ) {
		$update_args['autoload'] = wp_determine_option_autoload_value( $option, $value, $serialized_value, $autoload );
	} else {
		// Retrieve the current autoload value to reevaluate it in case it was set automatically.
		$raw_autoload = $wpdb->get_var( $wpdb->prepare( "SELECT autoload FROM $wpdb->options WHERE option_name = %s LIMIT 1", $option ) );
		$allow_values = array( 'auto-on', 'auto-off', 'auto' );
		if ( in_array( $raw_autoload, $allow_values, true ) ) {
			$autoload = wp_determine_option_autoload_value( $option, $value, $serialized_value, $autoload );
			if ( $autoload !== $raw_autoload ) {
				$update_args['autoload'] = $autoload;
			}
		}
	}

	$result = $wpdb->update( $wpdb->options, $update_args, array( 'option_name' => $option ) );
	if ( ! $result ) {
		return false;
	}

	$notoptions = wp_cache_get( 'notoptions', 'options' );

	if ( is_array( $notoptions ) && isset( $notoptions[ $option ] ) ) {
		unset( $notoptions[ $option ] );
		wp_cache_set( 'notoptions', $notoptions, 'options' );
	}

	if ( ! wp_installing() ) {
		if ( ! isset( $update_args['autoload'] ) ) {
			// Update the cached value based on where it is currently cached.
			$alloptions = wp_load_alloptions( true );

			if ( isset( $alloptions[ $option ] ) ) {
				$alloptions[ $option ] = $serialized_value;
				wp_cache_set( 'alloptions', $alloptions, 'options' );
			} else {
				wp_cache_set( $option, $serialized_value, 'options' );
			}
		} elseif ( in_array( $update_args['autoload'], wp_autoload_values_to_autoload(), true ) ) {
			// Delete the individual cache, then set in alloptions cache.
			wp_cache_delete( $option, 'options' );

			$alloptions = wp_load_alloptions( true );

			$alloptions[ $option ] = $serialized_value;
			wp_cache_set( 'alloptions', $alloptions, 'options' );
		} else {
			// Delete the alloptions cache, then set the individual cache.
			$alloptions = wp_load_alloptions( true );

			if ( isset( $alloptions[ $option ] ) ) {
				unset( $alloptions[ $option ] );
				wp_cache_set( 'alloptions', $alloptions, 'options' );
			}

			wp_cache_set( $option, $serialized_value, 'options' );
		}
	}

	/**
	 * Fires after a specific option has been updated.
	 *
	 * The dynamic portion of the hook name, `$option`, refers to the option name.
	 *
	 * @since 2.0.1
	 * @since 4.4.0 The `$option` parameter was added.
	 *
	 * @param mixed  $old_value The old option value.
	 * @param mixed  $value     The new option value.
	 * @param string $option    Option name.
	 */
	do_action( "update_option_{$option}", $old_value, $value, $option );

	/**
	 * Fires after an option has been updated.
	 *
	 * @since 2.9.0
	 *
	 * @param string $option    Name of the updated option.
	 * @param mixed  $old_value The old option value.
	 * @param mixed  $value     The new option value.
	 */
	do_action( 'updated_option', $option, $old_value, $value );

	return true;
}
```

**Key Points:**
- Automatically serializes arrays and objects
- Returns `false` if the value hasn't changed (no database update)
- If option doesn't exist, it calls `add_option()` internally
- Can update autoload value when updating the option value
- Values are sanitized via `sanitize_option()`

**Example - Basic Usage:**
```php
// Update a simple option
update_option( 'my_plugin_setting', 'new_value' );

// Update with autoload control
update_option( 'my_plugin_setting', 'new_value', false ); // Don't autoload

// Update an array (automatically serialized)
update_option( 'my_plugin_settings', array(
	'key1' => 'value1',
	'key2' => 'value2',
) );

// Update only if value changed
$new_value = 'updated_value';
if ( get_option( 'my_plugin_setting' ) !== $new_value ) {
	update_option( 'my_plugin_setting', $new_value );
}
```

**Example - Using Actions:**
```php
// Hook into option updates
add_action( 'update_option_my_plugin_setting', function( $old_value, $value, $option ) {
	// Log changes
	error_log( sprintf( 'Option %s changed from %s to %s', $option, $old_value, $value ) );
}, 10, 3 );

// Hook into all option updates
add_action( 'updated_option', function( $option, $old_value, $value ) {
	if ( 'my_plugin_' === substr( $option, 0, 11 ) ) {
		// Clear related caches
		wp_cache_flush_group( 'my_plugin' );
	}
}, 10, 3 );
```

### Adding Options

**Function:** `add_option( $option, $value = '', $deprecated = '', $autoload = null )`

Adds a new option only if it doesn't already exist. Use this when you want to ensure an option is only set once.

**Key Points:**
- Returns `false` if option already exists
- Use for initial setup or default values
- Prevents overwriting existing options

**Example:**
```php
// Add option only if it doesn't exist
if ( false === get_option( 'my_plugin_version' ) ) {
	add_option( 'my_plugin_version', '1.0.0', '', false ); // Non-autoloaded
}

// Or use add_option directly (it checks internally)
add_option( 'my_plugin_version', '1.0.0', '', false );
```

### Deleting Options

**Function:** `delete_option( $option )`

Removes an option from the database. Returns `true` if deleted, `false` if it didn't exist.

**Core Implementation:**
```1202:1280:wordpress/wp-includes/option.php
function delete_option( $option ) {
	global $wpdb;

	if ( is_scalar( $option ) ) {
		$option = trim( $option );
	}

	if ( empty( $option ) ) {
		return false;
	}

	wp_protect_special_option( $option );

	// Get the ID, if no ID then return.
	$row = $wpdb->get_row( $wpdb->prepare( "SELECT autoload FROM $wpdb->options WHERE option_name = %s", $option ) );
	if ( is_null( $row ) ) {
		return false;
	}

	/**
	 * Fires immediately before an option is deleted.
	 *
	 * @since 2.9.0
	 *
	 * @param string $option Name of the option to delete.
	 */
	do_action( 'delete_option', $option );

	$result = $wpdb->delete( $wpdb->options, array( 'option_name' => $option ) );

	if ( ! wp_installing() ) {
		if ( in_array( $row->autoload, wp_autoload_values_to_autoload(), true ) ) {
			$alloptions = wp_load_alloptions( true );

			if ( is_array( $alloptions ) && isset( $alloptions[ $option ] ) ) {
				unset( $alloptions[ $option ] );
				wp_cache_set( 'alloptions', $alloptions, 'options' );
			}
		} else {
			wp_cache_delete( $option, 'options' );
		}

		$notoptions = wp_cache_get( 'notoptions', 'options' );

		if ( ! is_array( $notoptions ) ) {
			$notoptions = array();
		}
		$notoptions[ $option ] = true;

		wp_cache_set( 'notoptions', $notoptions, 'options' );
	}

	if ( $result ) {

		/**
		 * Fires after a specific option has been deleted.
		 *
		 * The dynamic portion of the hook name, `$option`, refers to the option name.
		 *
		 * @since 3.0.0
		 *
		 * @param string $option Name of the deleted option.
		 */
		do_action( "delete_option_{$option}", $option );

		/**
		 * Fires after an option has been deleted.
		 *
		 * @since 2.9.0
		 *
		 * @param string $option Name of the deleted option.
		 */
		do_action( 'deleted_option', $option );

		return true;
	}

	return false;
}
```

**Key Points:**
- Removes option from database and all caches
- Updates `notoptions` cache to prevent unnecessary lookups
- Protected options cannot be deleted

**Example:**
```php
// Delete an option
if ( delete_option( 'my_plugin_old_setting' ) ) {
	error_log( 'Option deleted successfully' );
}

// Clean up on plugin deactivation
register_deactivation_hook( __FILE__, function() {
	delete_option( 'my_plugin_temp_data' );
	delete_option( 'my_plugin_cache' );
} );
```

---

## 2. Differentiate Between Autoloaded and Non-Autoloaded Options

### Understanding Autoload

**Autoloaded Options:**
- Loaded automatically on every page request via `wp_load_alloptions()`
- Stored in the `alloptions` cache
- Accessed immediately without a database query
- Best for frequently used options (e.g., `siteurl`, `home`, `admin_email`)

**Non-Autoloaded Options:**
- Loaded only when explicitly requested via `get_option()`
- Require a database query (or cache lookup) when accessed
- Best for rarely used options or large option values
- Reduces initial page load time and memory usage

### How Autoload Works

**Core Implementation:**
```601:662:wordpress/wp-includes/option.php
function wp_load_alloptions( $force_cache = false ) {
	global $wpdb;

	/**
	 * Filters the array of alloptions before it is populated.
	 *
	 * Returning an array from the filter will effectively short circuit
	 * wp_load_alloptions(), returning that value instead.
	 *
	 * @since 6.2.0
	 *
	 * @param array|null $alloptions  An array of alloptions. Default null.
	 * @param bool       $force_cache Whether to force an update of the local cache from the persistent cache. Default false.
	 */
	$alloptions = apply_filters( 'pre_wp_load_alloptions', null, $force_cache );
	if ( is_array( $alloptions ) ) {
		return $alloptions;
	}

	if ( ! wp_installing() || ! is_multisite() ) {
		$alloptions = wp_cache_get( 'alloptions', 'options', $force_cache );
	} else {
		$alloptions = false;
	}

	if ( ! $alloptions ) {
		$suppress      = $wpdb->suppress_errors();
		$alloptions_db = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options WHERE autoload IN ( '" . implode( "', '", esc_sql( wp_autoload_values_to_autoload() ) ) . "' )" );

		if ( ! $alloptions_db ) {
			$alloptions_db = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options" );
		}
		$wpdb->suppress_errors( $suppress );

		$alloptions = array();
		foreach ( (array) $alloptions_db as $o ) {
			$alloptions[ $o->option_name ] = $o->option_value;
		}

		if ( ! wp_installing() || ! is_multisite() ) {
			/**
			 * Filters all options before caching them.
			 *
			 * @since 4.9.0
			 *
			 * @param array $alloptions Array with all options.
			 */
			$alloptions = apply_filters( 'pre_cache_alloptions', $alloptions );

			wp_cache_add( 'alloptions', $alloptions, 'options' );
		}
	}

	/**
	 * Filters all options after retrieving them.
	 *
	 * @since 4.9.0
	 *
	 * @param array $alloptions Array with all options.
	 */
	return apply_filters( 'alloptions', $alloptions );
}
```

**Autoload Values:**
```3259:3275:wordpress/wp-includes/option.php
function wp_autoload_values_to_autoload() {
	$autoload_values = array( 'yes', 'on', 'auto-on', 'auto' );

	/**
	 * Filters the autoload values that should be considered for autoloading from the options table.
	 *
	 * The filter can only be used to remove autoload values from the default list.
	 *
	 * @since 6.6.0
	 *
	 * @param string[] $autoload_values Autoload values used to autoload option.
	 *                               Default list contains 'yes', 'on', 'auto-on', and 'auto'.
	 */
	$filtered_values = apply_filters( 'wp_autoload_values_to_autoload', $autoload_values );

	return array_intersect( $filtered_values, $autoload_values );
}
```

**Autoload Determination:**
```1307:1339:wordpress/wp-includes/option.php
function wp_determine_option_autoload_value( $option, $value, $serialized_value, $autoload ) {

	// Check if autoload is a boolean.
	if ( is_bool( $autoload ) ) {
		return $autoload ? 'on' : 'off';
	}

	switch ( $autoload ) {
		case 'on':
		case 'yes':
			return 'on';
		case 'off':
		case 'no':
			return 'off';
	}

	/**
	 * Allows to determine the default autoload value for an option where no explicit value is passed.
	 *
	 * @since 6.6.0
	 *
	 * @param bool|null $autoload The default autoload value to set. Returning true will be set as 'auto-on' in the
	 *                            database, false will be set as 'auto-off', and null will be set as 'auto'.
	 * @param string    $option   The passed option name.
	 * @param mixed     $value    The passed option value to be saved.
	 */
	$autoload = apply_filters( 'wp_default_autoload_value', null, $option, $value, $serialized_value );
	if ( is_bool( $autoload ) ) {
		return $autoload ? 'auto-on' : 'auto-off';
	}

	return 'auto';
}
```

### Setting Autoload Values

**When Adding Options:**
```php
// Autoloaded option (default for small, frequently used options)
add_option( 'my_plugin_site_name', 'My Site', '', true );

// Non-autoloaded option (for large or rarely used options)
add_option( 'my_plugin_large_data', $large_array, '', false );

// Let WordPress decide (null)
add_option( 'my_plugin_setting', 'value', '', null );
```

**When Updating Options:**
```php
// Update value and change autoload status
update_option( 'my_plugin_setting', 'new_value', false ); // Set to non-autoloaded

// Update value without changing autoload
update_option( 'my_plugin_setting', 'new_value' ); // Autoload unchanged
```

**Changing Autoload Without Updating Value:**
```php
// Change autoload value for a single option
wp_set_option_autoload( 'my_plugin_setting', false );

// Change autoload for multiple options
wp_set_options_autoload( array( 'option1', 'option2', 'option3' ), false );

// Set different autoload values for different options
wp_set_option_autoload_values( array(
	'option1' => true,  // Autoload
	'option2' => false, // Don't autoload
	'option3' => true,
) );
```

### Best Practices for Autoload

**Autoload (true) - Use for:**
- Options used on most page loads
- Small option values (< 1KB)
- Core WordPress settings (siteurl, home, etc.)
- Frequently accessed plugin settings

**Don't Autoload (false) - Use for:**
- Large option values (> 1KB)
- Options only used on specific pages (admin, specific templates)
- Rarely accessed settings
- Temporary or cached data

**Example - Decision Making:**
```php
// Good: Autoload frequently used, small option
add_option( 'my_plugin_active', true, '', true );

// Good: Don't autoload large data
add_option( 'my_plugin_export_data', $large_export_array, '', false );

// Good: Don't autoload admin-only settings
add_option( 'my_plugin_admin_notices', array(), '', false );

// Bad: Autoloading large option
add_option( 'my_plugin_all_posts_data', $huge_array, '', true ); // ❌

// Bad: Not autoloading frequently used option
add_option( 'my_plugin_site_name', 'My Site', '', false ); // ❌
```

---

## 3. Optimize Performance When Working with Large Option Sets

### Performance Considerations

**Problems with Large Option Sets:**
1. **Memory Usage:** All autoloaded options are loaded into memory on every request
2. **Database Queries:** Loading all autoloaded options requires a single large query
3. **Cache Size:** Large `alloptions` cache can impact object cache performance
4. **Serialization Overhead:** Large serialized arrays/objects increase processing time

### Strategies for Optimization

#### 1. Use Non-Autoloaded Options for Large Data

**Example:**
```php
// ❌ Bad: Autoloading large option
$large_data = array( /* thousands of items */ );
add_option( 'my_plugin_all_data', $large_data, '', true );

// ✅ Good: Non-autoloaded large option
add_option( 'my_plugin_all_data', $large_data, '', false );

// Access only when needed
if ( is_admin() ) {
	$data = get_option( 'my_plugin_all_data' );
}
```

#### 2. Split Large Options into Smaller Options

**Example:**
```php
// ❌ Bad: One massive option
$all_settings = array(
	'general' => array( /* 100 items */ ),
	'advanced' => array( /* 100 items */ ),
	'display' => array( /* 100 items */ ),
);
update_option( 'my_plugin_all_settings', $all_settings );

// ✅ Good: Split into logical groups
update_option( 'my_plugin_general_settings', $all_settings['general'], false );
update_option( 'my_plugin_advanced_settings', $all_settings['advanced'], false );
update_option( 'my_plugin_display_settings', $all_settings['display'], false );

// Load only what's needed
if ( is_admin_page( 'general' ) ) {
	$settings = get_option( 'my_plugin_general_settings' );
}
```

#### 3. Use wp_prime_option_caches() for Multiple Options

**Example:**
```php
// ❌ Bad: Multiple individual queries
$option1 = get_option( 'my_plugin_option1' );
$option2 = get_option( 'my_plugin_option2' );
$option3 = get_option( 'my_plugin_option3' );

// ✅ Good: Prime cache with single query
wp_prime_option_caches( array( 'my_plugin_option1', 'my_plugin_option2', 'my_plugin_option3' ) );
$option1 = get_option( 'my_plugin_option1' );
$option2 = get_option( 'my_plugin_option2' );
$option3 = get_option( 'my_plugin_option3' );

// Or use get_options() helper
$options = get_options( array( 'my_plugin_option1', 'my_plugin_option2', 'my_plugin_option3' ) );
```

#### 4. Batch Update Autoload Values

**Example:**
```php
// On plugin activation: Set rarely used options to non-autoloaded
register_activation_hook( __FILE__, function() {
	wp_set_options_autoload( array(
		'my_plugin_export_data',
		'my_plugin_backup_data',
		'my_plugin_log_data',
	), false );
} );

// On plugin deactivation: Disable autoload for all plugin options
register_deactivation_hook( __FILE__, function() {
	global $wpdb;
	$options = $wpdb->get_col( $wpdb->prepare(
		"SELECT option_name FROM $wpdb->options WHERE option_name LIKE %s",
		'my_plugin_%'
	) );
	if ( ! empty( $options ) ) {
		wp_set_options_autoload( $options, false );
	}
} );
```

#### 5. Monitor and Clean Up Autoloaded Options

**Example:**
```php
// Check autoloaded options size
function my_plugin_check_autoloaded_options() {
	global $wpdb;

	$autoloaded = $wpdb->get_results(
		"SELECT option_name, LENGTH(option_value) as size
		FROM $wpdb->options
		WHERE autoload IN ('yes', 'on', 'auto-on', 'auto')
		ORDER BY size DESC
		LIMIT 20"
	);

	foreach ( $autoloaded as $option ) {
		if ( $option->size > 1024 ) { // Larger than 1KB
			error_log( sprintf(
				'Large autoloaded option: %s (%d bytes)',
				$option->option_name,
				$option->size
			) );
		}
	}
}

// Run periodically via WP-Cron
add_action( 'my_plugin_check_options', 'my_plugin_check_autoloaded_options' );
```

#### 6. Use Transients for Temporary Data

**Example:**
```php
// ❌ Bad: Storing temporary data as options
update_option( 'my_plugin_api_cache', $api_data );
update_option( 'my_plugin_api_cache_time', time() );

// ✅ Good: Use transients for temporary data
set_transient( 'my_plugin_api_cache', $api_data, HOUR_IN_SECONDS );
```

#### 7. Implement Option Grouping

**Example:**
```php
// Prime options by group
function my_plugin_load_settings_group( $group ) {
	$option_groups = array(
		'general' => array( 'option1', 'option2', 'option3' ),
		'advanced' => array( 'option4', 'option5', 'option6' ),
	);

	if ( isset( $option_groups[ $group ] ) ) {
		wp_prime_option_caches( $option_groups[ $group ] );
	}
}

// Load only needed group
if ( is_admin_page( 'general' ) ) {
	my_plugin_load_settings_group( 'general' );
}
```

### Real-World Example: Optimizing Plugin Options

```php
class My_Plugin_Options {

	/**
	 * Initialize plugin options with optimal autoload settings.
	 */
	public static function init() {
		// Frequently used, small options - autoload
		add_option( 'my_plugin_active', true, '', true );
		add_option( 'my_plugin_version', '1.0.0', '', true );

		// Admin-only settings - don't autoload
		add_option( 'my_plugin_admin_settings', array(), '', false );

		// Large data - don't autoload
		add_option( 'my_plugin_export_data', array(), '', false );

		// Cache data - use transients instead
		// (handled elsewhere)
	}

	/**
	 * Get multiple options efficiently.
	 */
	public static function get_settings( $group = 'general' ) {
		$option_map = array(
			'general' => array( 'option1', 'option2', 'option3' ),
			'advanced' => array( 'option4', 'option5' ),
		);

		if ( ! isset( $option_map[ $group ] ) ) {
			return array();
		}

		// Prime cache with single query
		wp_prime_option_caches( $option_map[ $group ] );

		// Retrieve all at once
		return get_options( $option_map[ $group ] );
	}

	/**
	 * Clean up autoloaded options on deactivation.
	 */
	public static function cleanup() {
		global $wpdb;

		$options = $wpdb->get_col( $wpdb->prepare(
			"SELECT option_name FROM $wpdb->options WHERE option_name LIKE %s",
			'my_plugin_%'
		) );

		if ( ! empty( $options ) ) {
			// Set all to non-autoloaded
			wp_set_options_autoload( $options, false );
		}
	}
}

// Register hooks
register_activation_hook( __FILE__, array( 'My_Plugin_Options', 'init' ) );
register_deactivation_hook( __FILE__, array( 'My_Plugin_Options', 'cleanup' ) );
```

---

## Common Pitfalls and Best Practices

### Pitfalls

1. **Not Providing Default Values:** Always provide defaults to distinguish between "not set" and "false"
2. **Autoloading Large Options:** Large options should never be autoloaded
3. **Multiple Individual Queries:** Use `wp_prime_option_caches()` or `get_options()` for multiple options
4. **Storing Resources:** Cannot serialize resources (file handles, database connections)
5. **Not Cleaning Up:** Remove options on plugin uninstall

### Best Practices

1. **Always Provide Defaults:** `get_option( 'option', 'default' )`
2. **Use Appropriate Autoload:** Small, frequent = autoload; Large, rare = don't autoload
3. **Batch Operations:** Use `get_options()` or `wp_prime_option_caches()` for multiple options
4. **Sanitize on Save:** WordPress handles this via `sanitize_option()`, but be aware
5. **Clean Up on Uninstall:** Delete options when plugin is uninstalled
6. **Use Transients for Temporary Data:** Don't use options for cache-like data
7. **Monitor Option Sizes:** Regularly check for large autoloaded options

---

## Additional Resources

- [Options API - WordPress Developer Resources](https://developer.wordpress.org/plugins/settings/options-api/)
- [Function Reference: get_option()](https://developer.wordpress.org/reference/functions/get_option/)
- [Function Reference: update_option()](https://developer.wordpress.org/reference/functions/update_option/)
- [Function Reference: delete_option()](https://developer.wordpress.org/reference/functions/delete_option/)
- [Function Reference: add_option()](https://developer.wordpress.org/reference/functions/add_option/)
- [WordPress Performance: Options Autoloading](https://make.wordpress.org/core/2021/09/27/options-autoloading-improvements-in-wordpress-6-4/)
