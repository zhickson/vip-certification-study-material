# 1.13 Post Meta - Study Notes

## Overview

Post meta (custom fields) allows you to store additional data associated with posts. WordPress stores post meta in the `wp_postmeta` table with a key-value structure. Understanding how to store, retrieve, and query metadata efficiently is crucial for WordPress development.

**Key Reference:** [Custom Fields - WordPress Developer Resources](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)

---

## 1. Use get_post_meta and update_post_meta

### Getting Post Meta

**Function:** `get_post_meta( $post_id, $key = '', $single = false )`

```php
// Get single value
$price = get_post_meta( $post_id, 'price', true );

// Get all values (array)
$prices = get_post_meta( $post_id, 'price', false );

// Get all meta for post
$all_meta = get_post_meta( $post_id );
```

**Parameters:**
- `$post_id` - Post ID
- `$key` - Meta key (empty for all meta)
- `$single` - Return single value (true) or array (false)

### Updating Post Meta

**Function:** `update_post_meta( $post_id, $meta_key, $meta_value, $prev_value = '' )`

```php
// Update or add meta
update_post_meta( $post_id, 'price', 99.99 );

// Update specific value (when multiple exist)
update_post_meta( $post_id, 'price', 99.99, 49.99 );
```

**Function:** `add_post_meta( $post_id, $meta_key, $meta_value, $unique = false )`

```php
// Add meta (allows duplicates)
add_post_meta( $post_id, 'tag', 'featured' );
add_post_meta( $post_id, 'tag', 'sale' );

// Add unique meta
add_post_meta( $post_id, 'sku', 'PROD-001', true );
```

**Function:** `delete_post_meta( $post_id, $meta_key, $meta_value = '' )`

```php
// Delete all meta with key
delete_post_meta( $post_id, 'price' );

// Delete specific value
delete_post_meta( $post_id, 'tag', 'featured' );
```

---

## 2. Handle Serialized Data Safely

### Serialized Data

WordPress automatically serializes arrays and objects when storing in post meta:

```php
// Storing array
$data = array( 'color' => 'red', 'size' => 'large' );
update_post_meta( $post_id, 'attributes', $data );

// Retrieving
$data = get_post_meta( $post_id, 'attributes', true );
// Returns: array( 'color' => 'red', 'size' => 'large' )
```

### Safe Serialization

**1. Always Unserialize:**
```php
$value = get_post_meta( $post_id, 'complex_data', true );
if ( is_serialized( $value ) ) {
	$value = maybe_unserialize( $value );
}
```

**2. Use maybe_unserialize():**
```php
$value = maybe_unserialize( get_post_meta( $post_id, 'data', true ) );
```

**3. Avoid Manual Serialization:**
```php
// ❌ BAD
update_post_meta( $post_id, 'data', serialize( $array ) );

// ✅ GOOD
update_post_meta( $post_id, 'data', $array ); // WordPress handles it
```

### JSON Alternative

For better compatibility, consider JSON:

```php
// Store as JSON
update_post_meta( $post_id, 'data', wp_json_encode( $array ) );

// Retrieve
$data = json_decode( get_post_meta( $post_id, 'data', true ), true );
```

---

## 3. Optimize Queries on Large Meta Datasets

### Meta Query Performance

**1. Use Specific Meta Keys:**
```php
// ✅ GOOD - Specific key
$args = array(
	'meta_key' => 'price',
	'meta_value' => 100,
	'meta_compare' => '>=',
);

// ❌ BAD - LIKE query
$args = array(
	'meta_query' => array(
		array(
			'key' => 'price',
			'value' => '100',
			'compare' => 'LIKE', // Slow!
		),
	),
);
```

**2. Add Database Indexes:**
```sql
-- Add index for frequently queried meta key
ALTER TABLE wp_postmeta ADD INDEX meta_key_value (meta_key, meta_value(191));
```

**3. Limit Results:**
```php
$args = array(
	'meta_key' => 'featured',
	'meta_value' => 'yes',
	'posts_per_page' => 10, // Always limit!
);
```

**4. Cache Results:**
```php
$cache_key = 'featured_posts_' . md5( serialize( $args ) );
$posts = wp_cache_get( $cache_key );
if ( false === $posts ) {
	$query = new WP_Query( $args );
	$posts = $query->posts;
	wp_cache_set( $cache_key, $posts, '', 3600 );
}
```

---

## 4. Use Meta Queries in WP_Query Appropriately

### Simple Meta Queries

```php
$args = array(
	'post_type' => 'product',
	'meta_key' => 'featured',
	'meta_value' => 'yes',
);

$query = new WP_Query( $args );
```

### Complex Meta Queries

```php
$args = array(
	'post_type' => 'product',
	'meta_query' => array(
		'relation' => 'AND',
		array(
			'key' => 'price',
			'value' => 100,
			'compare' => '>=',
			'type' => 'NUMERIC',
		),
		array(
			'key' => 'featured',
			'value' => 'yes',
			'compare' => '=',
		),
	),
);

$query = new WP_Query( $args );
```

### Meta Query Operators

- `=` - Equal
- `!=` - Not equal
- `>` - Greater than
- `>=` - Greater than or equal
- `<` - Less than
- `<=` - Less than or equal
- `LIKE` - Pattern match (slow!)
- `NOT LIKE` - Not pattern match
- `IN` - In array
- `NOT IN` - Not in array
- `BETWEEN` - Between two values
- `NOT BETWEEN` - Not between
- `EXISTS` - Key exists
- `NOT EXISTS` - Key doesn't exist

---

## 5. Recognize Risks of Frequent Meta Updates (Performance, Locking)

### Performance Risks

**1. Database Locking:**
```php
// ❌ BAD - Multiple updates in loop
foreach ( $posts as $post ) {
	update_post_meta( $post->ID, 'processed', 'yes' );
}

// ✅ GOOD - Batch update or use transients
$processed = get_transient( 'processed_posts' );
if ( ! is_array( $processed ) ) {
	$processed = array();
}
$processed[] = $post_id;
set_transient( 'processed_posts', $processed, HOUR_IN_SECONDS );
```

**2. Transaction Overhead:**
- Each `update_post_meta()` is a separate database query
- Use batch operations when possible
- Consider custom tables for high-frequency data

**3. Cache Invalidation:**
```php
// Clear object cache after meta update
update_post_meta( $post_id, 'price', $new_price );
clean_post_cache( $post_id );
```

### Best Practices

- Batch updates when possible
- Use transients for temporary data
- Consider custom tables for high-frequency updates
- Clear caches after updates
- Use `update_metadata()` for bulk operations

---

## Exam Tips

### Key Points to Remember

1. **Post Meta Functions:**
   - `get_post_meta()` - Retrieve meta
   - `update_post_meta()` - Update/add meta
   - `add_post_meta()` - Add meta (allows duplicates)
   - `delete_post_meta()` - Delete meta

2. **Serialization:**
   - WordPress auto-serializes arrays/objects
   - Use `maybe_unserialize()` when needed
   - Consider JSON for better compatibility

3. **Performance:**
   - Use specific meta keys
   - Add database indexes
   - Cache query results
   - Limit result sets

4. **Risks:**
   - Frequent updates cause database locking
   - LIKE queries are slow
   - Large meta datasets need optimization

---

## Additional Resources

- [Custom Fields - WordPress Developer Resources](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)
- [Function Reference: get_post_meta](https://developer.wordpress.org/reference/functions/get_post_meta/)
- [Function Reference: update_post_meta](https://developer.wordpress.org/reference/functions/update_post_meta/)
- Core Files:
  - `wp-includes/meta.php` - Meta functions
