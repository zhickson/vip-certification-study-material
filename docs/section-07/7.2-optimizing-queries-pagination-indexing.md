# 7.2 Optimizing Queries, Pagination, and Indexing - Study Notes

## Overview

Making content rendering scalable requires optimising database queries, implementing efficient pagination, and applying proper indexing strategies. This ensures WordPress can handle large datasets efficiently.

**Key Reference:** [WP_Query - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_query/)

---

## 1. Using Pagination to Limit Results

### Standard WordPress Pagination

**Basic Pagination:**
```php
$paged = get_query_var( 'paged' ) ? get_query_var( 'paged' ) : 1;

$query = new WP_Query( array(
	'post_type' => 'product',
	'posts_per_page' => 20,
	'paged' => $paged,
) );

// Display pagination links
the_posts_pagination( array(
	'mid_size' => 2,
	'prev_text' => __( 'Previous', 'textdomain' ),
	'next_text' => __( 'Next', 'textdomain' ),
) );
```

**Archive Pagination:**
```php
// For archive pages, use posts_per_archive_page
$query = new WP_Query( array(
	'post_type' => 'product',
	'posts_per_archive_page' => 30,
) );
```

### Efficient Pagination Patterns

**Skip Found Rows When Not Needed:**
```php
// ✅ GOOD - Skip pagination count query
$query = new WP_Query( array(
	'post_type' => 'product',
	'posts_per_page' => 20,
	'no_found_rows' => true, // Skips expensive COUNT query
) );
```

**Cursor-Based Pagination (Better for Large Datasets):**
```php
// ✅ GOOD - Cursor-based pagination avoids offset issues
$last_id = isset( $_GET['after'] ) ? intval( $_GET['after'] ) : 0;

$query = new WP_Query( array(
	'post_type' => 'product',
	'posts_per_page' => 20,
	'meta_key' => 'id',
	'meta_value' => $last_id,
	'meta_compare' => '>',
	'orderby' => 'meta_value_num',
	'order' => 'ASC',
) );

// Get last ID for next page
$last_id = end( $query->posts )->ID;
```

**Avoid Offset-Based Pagination on Large Tables:**
```php
// ❌ BAD - Offset becomes slow with large datasets
$query = new WP_Query( array(
	'posts_per_page' => 20,
	'offset' => 1000, // Very slow on large tables
) );

// ✅ GOOD - Use cursor-based or date-based pagination
$query = new WP_Query( array(
	'posts_per_page' => 20,
	'date_query' => array(
		array(
			'before' => $last_date,
		),
	),
) );
```

---

## 2. Restricting Fields Returned in Queries

### Using Fields Parameter

**Get Only IDs:**
```php
// ✅ GOOD - Only get post IDs, not full objects
$query = new WP_Query( array(
	'post_type' => 'product',
	'fields' => 'ids', // Reduces memory significantly
	'posts_per_page' => 100,
) );

// Load full objects only when needed
foreach ( $query->posts as $post_id ) {
	$post = get_post( $post_id );
	// Process post
}
```

**Get ID and Parent Only:**
```php
$query = new WP_Query( array(
	'post_type' => 'product',
	'fields' => 'id=>parent', // Only ID and parent ID
) );
```

### Selecting Specific Post Fields

**Custom Field Selection:**
```php
// For custom queries, select only needed columns
global $wpdb;
$results = $wpdb->get_results( $wpdb->prepare(
	"SELECT ID, post_title, post_date
	FROM {$wpdb->posts}
	WHERE post_type = %s
	AND post_status = 'publish'
	LIMIT %d",
	'product',
	20
) );
```

---

## 3. Avoiding Unbounded Loops

### Recognising Unbounded Loops

**Common Patterns to Avoid:**
```php
// ❌ BAD - No limit
$query = new WP_Query( array(
	'post_type' => 'product',
) );

// ❌ BAD - Unlimited with -1
$posts = get_posts( array(
	'posts_per_page' => -1,
) );

// ❌ BAD - Loop without limit
while ( have_posts() ) {
	the_post();
	// Process all posts
}
```

### Implementing Bounded Loops

**Always Set Limits:**
```php
// ✅ GOOD - Explicit limit
$query = new WP_Query( array(
	'post_type' => 'product',
	'posts_per_page' => 20,
	'paged' => $paged,
) );

// ✅ GOOD - Process in batches
function process_in_batches( $batch_size = 50 ) {
	$paged = 1;

	do {
		$query = new WP_Query( array(
			'post_type' => 'product',
			'posts_per_page' => $batch_size,
			'paged' => $paged,
			'fields' => 'ids',
		) );

		foreach ( $query->posts as $post_id ) {
			process_post( $post_id );
		}

		$paged++;
		wp_reset_postdata();
	} while ( $query->have_posts() );
}
```

---

## 4. Applying Proper Indexes

### Understanding Database Indexes

**Primary Indexes:**
- Automatically created on primary keys
- Fast lookups by ID
- Used in JOIN operations

**Secondary Indexes:**
- Created on frequently queried columns
- Speed up WHERE, ORDER BY, and JOIN clauses
- Trade-off: Slightly slower INSERT/UPDATE

### Identifying Missing Indexes

**Check Query Performance:**
```sql
-- Use EXPLAIN to see index usage
EXPLAIN SELECT * FROM wp_posts
WHERE post_type = 'product'
AND post_status = 'publish'
ORDER BY post_date DESC;
```

**Common Missing Indexes:**
```sql
-- Post type and status
CREATE INDEX idx_post_type_status ON wp_posts(post_type, post_status);

-- Post date for ordering
CREATE INDEX idx_post_date ON wp_posts(post_date);

-- Meta queries
CREATE INDEX idx_meta_key_value ON wp_postmeta(meta_key, meta_value(191));
```

### Adding Indexes for WordPress Queries

**Post Meta Indexes:**
```php
// Add index for frequently queried meta keys
global $wpdb;
$wpdb->query( "
	CREATE INDEX idx_featured_price
	ON {$wpdb->postmeta}(meta_key, meta_value(191))
	WHERE meta_key IN ('featured', 'price')
" );
```

**Custom Table Indexes:**
```php
// For custom tables, add appropriate indexes
global $wpdb;
$wpdb->query( "
	CREATE TABLE {$wpdb->prefix}custom_data (
		id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
		post_id BIGINT UNSIGNED NOT NULL,
		data_key VARCHAR(255) NOT NULL,
		data_value TEXT,
		created_at DATETIME NOT NULL,
		PRIMARY KEY (id),
		INDEX idx_post_id (post_id),
		INDEX idx_data_key (data_key),
		INDEX idx_created_at (created_at)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
" );
```

### Composite Indexes

**Multi-Column Indexes:**
```sql
-- Composite index for common query patterns
CREATE INDEX idx_type_status_date
ON wp_posts(post_type, post_status, post_date);

-- Use in queries
SELECT * FROM wp_posts
WHERE post_type = 'product'
AND post_status = 'publish'
ORDER BY post_date DESC;
-- Uses composite index efficiently
```

---

## 5. Using Custom Tables for Large Datasets

### When to Use Custom Tables

**Consider Custom Tables When:**
- Very large datasets (millions of rows)
- Complex queries not efficient with post meta
- Need for specific indexes
- Frequent queries on specific data

**Example Custom Table:**
```php
function create_custom_table() {
	global $wpdb;
	$table_name = $wpdb->prefix . 'product_analytics';

	$charset_collate = $wpdb->get_charset_collate();

	$sql = "CREATE TABLE $table_name (
		id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
		product_id BIGINT UNSIGNED NOT NULL,
		event_type VARCHAR(50) NOT NULL,
		event_data TEXT,
		created_at DATETIME NOT NULL,
		PRIMARY KEY (id),
		INDEX idx_product_id (product_id),
		INDEX idx_event_type (event_type),
		INDEX idx_created_at (created_at),
		INDEX idx_product_event (product_id, event_type)
	) $charset_collate;";

	require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );
	dbDelta( $sql );
}
```

**Querying Custom Tables:**
```php
// Efficient query with indexes
global $wpdb;
$results = $wpdb->get_results( $wpdb->prepare(
	"SELECT * FROM {$wpdb->prefix}product_analytics
	WHERE product_id = %d
	AND event_type = %s
	ORDER BY created_at DESC
	LIMIT %d",
	$product_id,
	'view',
	100
) );
```

---

## 6. Optimising Query Arguments

### Efficient Query Patterns

**Use Specific Constraints:**
```php
// ✅ GOOD - Specific constraints
$query = new WP_Query( array(
	'post_type' => 'product',
	'post_status' => 'publish',
	'posts_per_page' => 20,
	'date_query' => array(
		array(
			'after' => '1 month ago',
		),
	),
) );
```

**Avoid Expensive Operations:**
```php
// ❌ BAD - Multiple meta queries
$query = new WP_Query( array(
	'meta_query' => array(
		'relation' => 'OR',
		array( 'key' => 'field1' ),
		array( 'key' => 'field2' ),
		array( 'key' => 'field3' ),
	),
) );

// ✅ GOOD - Use custom table or restructure
// Or limit to essential queries only
```

**Cache Query Results:**
```php
function get_cached_query( $args ) {
	$cache_key = 'query_' . md5( serialize( $args ) );
	$results = wp_cache_get( $cache_key );

	if ( false === $results ) {
		$query = new WP_Query( $args );
		$results = $query->posts;
		wp_cache_set( $cache_key, $results, '', 3600 );
	}

	return $results;
}
```

---

## Exam Tips

### Key Points to Remember

1. **Pagination:**
   - Always use `posts_per_page` with reasonable limits
   - Use `no_found_rows => true` when pagination not needed
   - Prefer cursor-based pagination for very large datasets
   - Avoid offset-based pagination on large tables

2. **Field Selection:**
   - Use `fields => 'ids'` to reduce memory
   - Select only needed columns in custom queries
   - Load full objects only when necessary

3. **Unbounded Loops:**
   - Never use `-1` for unlimited results
   - Always set explicit limits
   - Process large datasets in batches
   - Use WP-Cron for background processing

4. **Indexing:**
   - Add indexes for frequently queried columns
   - Use composite indexes for multi-column queries
   - Monitor query performance with EXPLAIN
   - Consider custom tables for very large datasets

5. **Query Optimization:**
   - Use specific constraints in queries
   - Cache expensive query results
   - Avoid multiple meta queries when possible
   - Use custom tables for complex data structures

---

## Additional Resources

- [WP_Query - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_query/)
- [Database Description - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wpdb/)
- [MySQL Indexes - MySQL Documentation](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)
- Core Files:
  - `wp-includes/class-wp-query.php` - Query class
  - `wp-includes/wp-db.php` - Database class
