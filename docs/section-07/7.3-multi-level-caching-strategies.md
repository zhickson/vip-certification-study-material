# 7.3 Multi-Level Caching Strategies - Study Notes

## Overview

Multi-level caching applies caching at object, fragment, and full-page levels to reduce server load and improve performance. Understanding when and how to use each caching layer is essential for scalable WordPress sites.

**Key Reference:** [Caching - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/performance/caching/)

---

## 1. Using Persistent Object Caches

### What is Object Caching?

Object caching stores PHP objects in memory (Redis, Memcached) to avoid repeated database queries.

**Core Implementation:**
```php
// WordPress object cache functions
wp_cache_get( $key, $group = '', $force = false, $found = null );
wp_cache_set( $key, $data, $group = '', $expiration = 0 );
wp_cache_delete( $key, $group = '' );
wp_cache_flush();
```

### Implementing Object Cache

**Basic Usage:**
```php
function get_cached_data( $key ) {
	$cache_key = 'my_data_' . $key;
	$data = wp_cache_get( $cache_key, 'my_group' );

	if ( false === $data ) {
		// Expensive operation
		$data = expensive_database_query( $key );

		// Cache for 1 hour
		wp_cache_set( $cache_key, $data, 'my_group', 3600 );
	}

	return $data;
}
```

**Cache Groups:**
```php
// Use groups to organise cache
wp_cache_set( 'post_123', $post_data, 'posts', 3600 );
wp_cache_set( 'user_456', $user_data, 'users', 3600 );

// Delete all in a group
wp_cache_flush_group( 'posts' );
```

### Persistent vs Non-Persistent

**With Persistent Cache (Redis/Memcached):**
- Stored in external memory
- Shared across PHP processes
- Survives between requests
- Very fast retrieval

**Without Persistent Cache:**
- Stored in-process memory only
- Lost after each request
- Not shared between processes
- Limited to single request

**Check if Persistent Cache is Available:**
```php
if ( wp_using_ext_object_cache() ) {
	// Persistent cache is available
	wp_cache_set( $key, $data, '', 3600 );
} else {
	// Fall back to transients
	set_transient( $key, $data, 3600 );
}
```

---

## 2. Caching Expensive Template Fragments

### Fragment Caching

Fragment caching stores rendered HTML output for reusable template parts.

**Basic Fragment Cache:**
```php
function get_cached_fragment( $key, $callback, $expiration = 3600 ) {
	$cache_key = 'fragment_' . $key;
	$output = wp_cache_get( $cache_key );

	if ( false === $output ) {
		ob_start();
		call_user_func( $callback );
		$output = ob_get_clean();

		wp_cache_set( $cache_key, $output, '', $expiration );
	}

	return $output;
}

// Usage
echo get_cached_fragment( 'recent_posts', function() {
	$query = new WP_Query( array(
		'posts_per_page' => 5,
		'orderby' => 'date',
	) );

	if ( $query->have_posts() ) {
		while ( $query->have_posts() ) {
			$query->the_post();
			// Output post HTML
		}
	}
}, 1800 ); // Cache for 30 minutes
```

### Cache Invalidation for Fragments

**Invalidate on Content Updates:**
```php
// Invalidate fragment cache on post save
add_action( 'save_post', function( $post_id ) {
	wp_cache_delete( 'fragment_recent_posts', '' );
	wp_cache_delete( 'fragment_featured_posts', '' );
} );

// Invalidate on term update
add_action( 'edited_term', function( $term_id ) {
	wp_cache_flush_group( 'fragments' );
} );
```

### Conditional Fragment Caching

**Cache Based on Context:**
```php
function get_contextual_fragment( $base_key ) {
	// Include context in cache key
	$context = array(
		'user_id' => get_current_user_id(),
		'language' => get_locale(),
		'theme' => get_stylesheet(),
	);

	$cache_key = 'fragment_' . $base_key . '_' . md5( serialize( $context ) );

	return wp_cache_get( $cache_key );
}
```

---

## 3. Implementing Full-Page Caching

### Plugin-Level Page Caching

**WP Super Cache / W3 Total Cache:**
```php
// Cache is handled automatically by plugin
// Manual cache clearing
if ( function_exists( 'wp_cache_clear_cache' ) ) {
	wp_cache_clear_cache();
}

// Clear cache on post update
add_action( 'save_post', function() {
	if ( function_exists( 'wp_cache_post_change' ) ) {
		wp_cache_post_change( get_the_ID() );
	}
} );
```

### Server-Level Page Caching

**Varnish Configuration:**
```vcl
sub vcl_recv {
	// Don't cache admin or logged-in users
	if (req.url ~ "^/(wp-admin|wp-login)" || req.http.Cookie ~ "wordpress_logged_in") {
		return (pass);
	}

	// Cache everything else
	return (hash);
}

sub vcl_backend_response {
	// Set cache TTL
	if (bereq.url !~ "^/(wp-admin|wp-login)") {
		set beresp.ttl = 1h;
		set beresp.http.Cache-Control = "public, max-age=3600";
	}
}
```

**Nginx FastCGI Cache:**
```nginx
fastcgi_cache_path /var/cache/nginx levels=1:2 keys_zone=WORDPRESS:100m inactive=60m;
fastcgi_cache_key "$scheme$request_method$host$request_uri";

server {
	location ~ \.php$ {
		fastcgi_cache WORDPRESS;
		fastcgi_cache_valid 200 60m;
		fastcgi_cache_bypass $skip_cache;
		fastcgi_no_cache $skip_cache;
	}
}
```

### Programmatic Page Cache Control

**Set Cache Headers:**
```php
// Set cache control headers
add_action( 'template_redirect', function() {
	if ( ! is_user_logged_in() && ! is_admin() ) {
		header( 'Cache-Control: public, max-age=3600' );
		header( 'Expires: ' . gmdate( 'D, d M Y H:i:s', time() + 3600 ) . ' GMT' );
	}
} );
```

**Bypass Cache for Specific Pages:**
```php
add_action( 'template_redirect', function() {
	if ( is_page( 'no-cache-page' ) ) {
		header( 'Cache-Control: no-cache, must-revalidate' );
		header( 'Pragma: no-cache' );
	}
} );
```

---

## 4. Balancing Caching Layers to Reduce Server Load

### Caching Hierarchy

**Typical Caching Stack:**
1. **CDN/Edge Cache** - Fastest, global distribution
2. **Page Cache** - Full HTML output
3. **Fragment Cache** - Template parts
4. **Object Cache** - Database query results
5. **Database** - Source of truth

### Cache Layer Strategy

**Object Cache for:**
- Database query results
- Expensive calculations
- API responses
- Short-lived data (< 1 hour)

**Fragment Cache for:**
- Rendered template parts
- Widget output
- Menu HTML
- Medium-lived data (30 min - 2 hours)

**Page Cache for:**
- Full page HTML
- Static content
- User-agnostic pages
- Long-lived data (1-24 hours)

### Cache Warming

**Pre-populate Cache:**
```php
function warm_cache() {
	// Warm object cache
	$popular_posts = get_posts( array(
		'posts_per_page' => 100,
		'meta_key' => 'view_count',
		'orderby' => 'meta_value_num',
	) );

	foreach ( $popular_posts as $post ) {
		// Trigger cache population
		get_post( $post->ID );
		update_post_meta_cache( array( $post->ID ) );
		update_post_term_cache( array( $post->ID ) );
	}

	// Warm page cache via WP-CLI or cron
	// wp cache flush && curl popular URLs
}
```

### Cache Invalidation Strategy

**Hierarchical Invalidation:**
```php
function invalidate_caches( $post_id ) {
	// 1. Invalidate object cache
	wp_cache_delete( 'post_' . $post_id, 'posts' );

	// 2. Invalidate fragment caches
	wp_cache_delete( 'fragment_recent_posts', '' );
	wp_cache_delete( 'fragment_related_posts_' . $post_id, '' );

	// 3. Invalidate page cache
	if ( function_exists( 'wp_cache_post_change' ) ) {
		wp_cache_post_change( $post_id );
	}

	// 4. Purge CDN cache (if applicable)
	do_action( 'cdn_purge_url', get_permalink( $post_id ) );
}
```

---

## 5. Monitoring Cache Performance

### Cache Hit Rates

**Track Cache Performance:**
```php
class Cache_Monitor {
	private static $stats = array();

	public static function track_get( $key, $hit ) {
		if ( ! isset( self::$stats[ $key ] ) ) {
			self::$stats[ $key ] = array( 'hits' => 0, 'misses' => 0 );
		}

		if ( $hit ) {
			self::$stats[ $key ]['hits']++;
		} else {
			self::$stats[ $key ]['misses']++;
		}
	}

	public static function get_stats() {
		return self::$stats;
	}
}

// Wrap cache gets
function monitored_cache_get( $key, $group = '' ) {
	$data = wp_cache_get( $key, $group, false, $found );
	Cache_Monitor::track_get( $key, $found );
	return $data;
}
```

### Cache Size Management

**Monitor Cache Memory:**
```php
// For Redis
$redis = new Redis();
$redis->connect( '127.0.0.1', 6379 );
$info = $redis->info( 'memory' );
$used_memory = $info['used_memory_human'];

// Set memory limits
$redis->config( 'SET', 'maxmemory', '256mb' );
$redis->config( 'SET', 'maxmemory-policy', 'allkeys-lru' );
```

---

## Exam Tips

### Key Points to Remember

1. **Object Cache:**
   - Use for database query results
   - Check `wp_using_ext_object_cache()` before use
   - Use cache groups for organisation
   - Set appropriate expiration times

2. **Fragment Cache:**
   - Cache rendered HTML output
   - Invalidate on content updates
   - Include context in cache keys
   - Use for reusable template parts

3. **Page Cache:**
   - Cache full HTML responses
   - Bypass for logged-in users
   - Set appropriate cache headers
   - Use server-level caching when possible

4. **Cache Hierarchy:**
   - CDN > Page > Fragment > Object > Database
   - Use appropriate layer for data type
   - Balance between layers
   - Monitor cache hit rates

5. **Cache Invalidation:**
   - Invalidate on content updates
   - Use hierarchical invalidation
   - Clear related caches
   - Consider cache warming strategies

---

## Additional Resources

- [Caching - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/performance/caching/)
- [Object Cache - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_object_cache/)
- [Transients API - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/transients/)
- Core Files:
  - `wp-includes/class-wp-object-cache.php` - Object cache implementation
  - `wp-includes/cache.php` - Cache helper functions
