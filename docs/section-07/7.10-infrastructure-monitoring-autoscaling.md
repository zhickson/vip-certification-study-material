# 7.10 Infrastructure Monitoring and Autoscaling - Study Notes

## Overview

Monitoring infrastructure metrics and implementing autoscaling ensures WordPress hosting environments can handle traffic spikes and maintain performance. Understanding monitoring tools and autoscaling strategies is essential for high-availability WordPress deployments.

**Key Reference:** [Monitoring - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/performance/monitoring/)

---

## 1. Using Tools Like New Relic or Datadog for Infrastructure Metrics

### Infrastructure Monitoring Basics

**What to Monitor:**
- CPU usage
- Memory usage
- Disk I/O
- Network traffic
- Database performance
- Application response times
- Error rates

### New Relic Integration

**Installation:**
```bash
# Install New Relic PHP agent
# Download from https://download.newrelic.com/php_agent/release/

# Add to php.ini
extension=newrelic.so
newrelic.license="YOUR_LICENSE_KEY"
newrelic.appname="WordPress Site"
```

**WordPress Configuration:**
```php
// Configure New Relic in wp-config.php
if ( extension_loaded( 'newrelic' ) ) {
	// Set application name
	newrelic_set_appname( 'WordPress Site' );

	// Ignore admin requests
	if ( is_admin() ) {
		newrelic_ignore_transaction();
	}

	// Add custom attributes
	newrelic_add_custom_attribute( 'user_id', get_current_user_id() );
	newrelic_add_custom_attribute( 'post_type', get_post_type() );
}
```

**Custom Metrics:**
```php
// Track custom metrics
function track_custom_metric( $metric_name, $value ) {
	if ( extension_loaded( 'newrelic' ) ) {
		newrelic_custom_metric( "Custom/{$metric_name}", $value );
	}
}

// Track query performance
add_action( 'wp_loaded', function() {
	global $wpdb;

	if ( extension_loaded( 'newrelic' ) ) {
		$query_count = count( $wpdb->queries );
		track_custom_metric( 'DatabaseQueries', $query_count );
	}
} );
```

**Transaction Tracking:**
```php
// Name transactions for better tracking
add_action( 'template_redirect', function() {
	if ( extension_loaded( 'newrelic' ) ) {
		if ( is_front_page() ) {
			newrelic_name_transaction( 'Homepage' );
		} elseif ( is_single() ) {
			newrelic_name_transaction( 'Single Post' );
		} elseif ( is_archive() ) {
			newrelic_name_transaction( 'Archive' );
		}
	}
} );
```

### Datadog Integration

**Installation:**
```bash
# Install Datadog agent
# Follow: https://docs.datadoghq.com/agent/

# Configure WordPress integration
# Add to datadog.yaml
```

**WordPress Integration:**
```php
// Send custom metrics to Datadog
function send_datadog_metric( $metric_name, $value, $tags = array() ) {
	$api_key = get_option( 'datadog_api_key' );
	$app_key = get_option( 'datadog_app_key' );

	if ( ! $api_key || ! $app_key ) {
		return;
	}

	$data = array(
		'series' => array(
			array(
				'metric' => $metric_name,
				'points' => array(
					array( time(), $value ),
				),
				'tags' => $tags,
			),
		),
	);

	wp_remote_post(
		'https://api.datadoghq.com/api/v1/series?api_key=' . $api_key,
		array(
			'body' => json_encode( $data ),
			'headers' => array(
				'Content-Type' => 'application/json',
			),
			'blocking' => false,
		)
	);
}

// Track WordPress metrics
add_action( 'wp_loaded', function() {
	global $wpdb;

	// Track query count
	send_datadog_metric(
		'wordpress.db.queries',
		count( $wpdb->queries ),
		array( 'env:production' )
	);

	// Track memory usage
	send_datadog_metric(
		'wordpress.memory.usage',
		memory_get_usage( true ),
		array( 'env:production' )
	);
} );
```

**APM (Application Performance Monitoring):**
```php
// Track custom spans
function track_custom_span( $operation_name, $callback ) {
	$start = microtime( true );
	$result = call_user_func( $callback );
	$duration = ( microtime( true ) - $start ) * 1000; // Convert to milliseconds

	// Send to Datadog APM
	send_datadog_metric(
		'wordpress.operation.duration',
		$duration,
		array( 'operation:' . $operation_name )
	);

	return $result;
}

// Usage
$result = track_custom_span( 'expensive_operation', function() {
	return perform_expensive_operation();
} );
```

---

## 2. Defining Thresholds for CPU, Memory, and Response Time

### Setting Monitoring Thresholds

**CPU Thresholds:**
```php
// Monitor CPU usage
function check_cpu_threshold() {
	$cpu_usage = sys_getloadavg()[0]; // 1-minute load average
	$cpu_threshold = 80; // 80% CPU usage

	if ( $cpu_usage > $cpu_threshold ) {
		// Alert or trigger autoscaling
		send_alert( 'CPU usage exceeded threshold: ' . $cpu_usage . '%' );
		trigger_autoscale( 'cpu', $cpu_usage );
	}
}
```

**Memory Thresholds:**
```php
// Monitor memory usage
function check_memory_threshold() {
	$memory_usage = memory_get_usage( true );
	$memory_limit = ini_get( 'memory_limit' );
	$memory_limit_bytes = wp_convert_hr_to_bytes( $memory_limit );
	$memory_percent = ( $memory_usage / $memory_limit_bytes ) * 100;
	$memory_threshold = 80; // 80% memory usage

	if ( $memory_percent > $memory_threshold ) {
		send_alert( 'Memory usage exceeded threshold: ' . $memory_percent . '%' );
		trigger_autoscale( 'memory', $memory_percent );
	}
}
```

**Response Time Thresholds:**
```php
// Monitor response time
add_action( 'init', function() {
	if ( ! defined( 'WP_CLI' ) ) {
		$start_time = microtime( true );

		add_action( 'shutdown', function() use ( $start_time ) {
			$response_time = ( microtime( true ) - $start_time ) * 1000; // Convert to milliseconds
			$response_threshold = 2000; // 2 seconds

			if ( $response_time > $response_threshold ) {
				send_alert( 'Response time exceeded threshold: ' . $response_time . 'ms' );
				log_slow_request( $_SERVER['REQUEST_URI'], $response_time );
			}

			// Track metric
			if ( function_exists( 'send_datadog_metric' ) ) {
				send_datadog_metric(
					'wordpress.response_time',
					$response_time,
					array( 'uri:' . $_SERVER['REQUEST_URI'] )
				);
			}
		} );
	}
} );
```

### Alerting Configuration

**Alert Rules:**
```php
class Monitoring_Alerts {
	private $thresholds = array(
		'cpu' => 80,
		'memory' => 80,
		'response_time' => 2000,
		'error_rate' => 5, // 5% error rate
	);

	public function check_thresholds() {
		$this->check_cpu();
		$this->check_memory();
		$this->check_response_time();
		$this->check_error_rate();
	}

	private function check_cpu() {
		$cpu = sys_getloadavg()[0];
		if ( $cpu > $this->thresholds['cpu'] ) {
			$this->send_alert( 'CPU', $cpu, $this->thresholds['cpu'] );
		}
	}

	private function send_alert( $metric, $value, $threshold ) {
		// Send alert via email, Slack, PagerDuty, etc.
		wp_mail(
			get_option( 'admin_email' ),
			'Alert: ' . $metric . ' Threshold Exceeded',
			"{$metric} is at {$value}%, exceeding threshold of {$threshold}%"
		);
	}
}
```

---

## 3. Configuring Auto-Scaling Groups or Container Clusters

### AWS Auto Scaling

**Auto Scaling Group Configuration:**
```json
{
	"AutoScalingGroupName": "wordpress-asg",
	"MinSize": 2,
	"MaxSize": 10,
	"DesiredCapacity": 3,
	"TargetGroupARNs": ["arn:aws:elasticloadbalancing:..."],
	"HealthCheckType": "ELB",
	"HealthCheckGracePeriod": 300,
	"ScalingPolicies": [
		{
			"PolicyName": "scale-up-cpu",
			"PolicyType": "TargetTrackingScaling",
			"TargetTrackingConfiguration": {
				"PredefinedMetricSpecification": {
					"PredefinedMetricType": "ASGAverageCPUUtilization"
				},
				"TargetValue": 70.0
			}
		}
	]
}
```

**CloudWatch Alarms:**
```php
// Create CloudWatch alarm for autoscaling
function create_autoscaling_alarm() {
	$cloudwatch = new Aws\CloudWatch\CloudWatchClient( array(
		'region' => 'us-east-1',
		'version' => 'latest',
	) );

	$cloudwatch->putMetricAlarm( array(
		'AlarmName' => 'wordpress-high-cpu',
		'ComparisonOperator' => 'GreaterThanThreshold',
		'EvaluationPeriods' => 2,
		'MetricName' => 'CPUUtilization',
		'Namespace' => 'AWS/EC2',
		'Period' => 300,
		'Statistic' => 'Average',
		'Threshold' => 70.0,
		'ActionsEnabled' => true,
		'AlarmActions' => array(
			'arn:aws:autoscaling:us-east-1:123456789012:scalingPolicy:...',
		),
	) );
}
```

### Kubernetes Autoscaling

**Horizontal Pod Autoscaler:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 15
      selectPolicy: Max
```

**Custom Metrics Autoscaling:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-custom-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
```

### Docker Swarm Autoscaling

**Service Scaling:**
```bash
# Scale service based on load
docker service scale wordpress=5

# Auto-scaling with external tool
# Use tools like Docker Swarm Autoscaler
```

---

## 4. Planning for Traffic Spikes and Failover

### Traffic Spike Planning

**Capacity Planning:**
```php
// Estimate capacity needed
function estimate_capacity( $expected_traffic, $avg_response_time, $target_response_time ) {
	$requests_per_second = $expected_traffic / 3600; // Per hour to per second
	$capacity_needed = ceil( $requests_per_second * ( $avg_response_time / 1000 ) );

	return array(
		'requests_per_second' => $requests_per_second,
		'servers_needed' => $capacity_needed,
		'buffer' => $capacity_needed * 1.5, // 50% buffer
	);
}
```

**Pre-Scaling:**
```php
// Scale up before expected traffic spike
function pre_scale_for_event( $event_start_time, $expected_traffic_multiplier ) {
	$time_until_event = $event_start_time - time();

	// Scale up 30 minutes before event
	if ( $time_until_event <= 1800 && $time_until_event > 0 ) {
		$current_capacity = get_current_capacity();
		$target_capacity = $current_capacity * $expected_traffic_multiplier;

		scale_to_capacity( $target_capacity );
	}
}
```

### Failover Planning

**Health Checks:**
```php
// Health check endpoint
add_action( 'rest_api_init', function() {
	register_rest_route( 'wp/v2', '/health', array(
		'methods' => 'GET',
		'callback' => 'health_check',
		'permission_callback' => '__return_true',
	) );
} );

function health_check() {
	$health = array(
		'status' => 'healthy',
		'timestamp' => time(),
		'checks' => array(),
	);

	// Check database
	global $wpdb;
	$db_check = $wpdb->get_var( 'SELECT 1' );
	$health['checks']['database'] = $db_check ? 'ok' : 'failed';

	// Check object cache
	$cache_check = wp_cache_get( 'health_check', 'system' );
	if ( $cache_check === false ) {
		wp_cache_set( 'health_check', 'ok', 'system', 60 );
		$cache_check = 'ok';
	}
	$health['checks']['cache'] = $cache_check;

	// Check disk space
	$disk_free = disk_free_space( ABSPATH );
	$disk_total = disk_total_space( ABSPATH );
	$disk_percent = ( 1 - ( $disk_free / $disk_total ) ) * 100;
	$health['checks']['disk'] = $disk_percent < 90 ? 'ok' : 'warning';

	// Determine overall status
	if ( in_array( 'failed', $health['checks'] ) ) {
		$health['status'] = 'unhealthy';
		status_header( 503 );
	}

	return new WP_REST_Response( $health, $health['status'] === 'healthy' ? 200 : 503 );
}
```

**Load Balancer Health Checks:**
```nginx
# Nginx health check configuration
location /health {
	access_log off;
	proxy_pass http://wordpress_backend/health;
	proxy_set_header Host $host;

	# Health check settings
	proxy_connect_timeout 2s;
	proxy_read_timeout 2s;
}
```

**Automatic Failover:**
```php
// Monitor and failover
class Failover_Manager {
	public function check_health() {
		$response = wp_remote_get( home_url( '/wp-json/wp/v2/health' ), array(
			'timeout' => 5,
		) );

		if ( is_wp_error( $response ) || wp_remote_retrieve_response_code( $response ) !== 200 ) {
			$this->trigger_failover();
		}
	}

	private function trigger_failover() {
		// Remove server from load balancer
		// Notify administrators
		// Scale up replacement servers
	}
}
```

---

## Exam Tips

### Key Points to Remember

1. **Monitoring Tools:**
   - New Relic: APM and infrastructure monitoring
   - Datadog: Comprehensive monitoring and APM
   - Track CPU, memory, response time, error rates

2. **Thresholds:**
   - Set appropriate thresholds for each metric
   - CPU: Typically 70-80%
   - Memory: Typically 80%
   - Response time: Typically 1-2 seconds
   - Configure alerts when thresholds exceeded

3. **Autoscaling:**
   - AWS Auto Scaling Groups
   - Kubernetes Horizontal Pod Autoscaler
   - Scale based on CPU, memory, or custom metrics
   - Set min/max replicas

4. **Traffic Spikes:**
   - Plan capacity for expected spikes
   - Pre-scale before known events
   - Monitor and scale reactively
   - Use load balancers for distribution

5. **Failover:**
   - Implement health checks
   - Configure automatic failover
   - Monitor all critical services
   - Test failover procedures regularly

---

## Additional Resources

- [Monitoring - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/performance/monitoring/)
- [New Relic Documentation](https://docs.newrelic.com/)
- [Datadog Documentation](https://docs.datadoghq.com/)
- [AWS Auto Scaling Documentation](https://docs.aws.amazon.com/autoscaling/)
- [Kubernetes Autoscaling](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
