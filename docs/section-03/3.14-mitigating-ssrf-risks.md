# 3.14 Mitigating SSRF Risks - Study Notes

## Overview

Mitigating SSRF risks requires validating URLs, blocking internal IPs, restricting protocols, and implementing proper access controls. This topic covers best practices for preventing SSRF attacks in WordPress.

**Key Reference:** [OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)

---

## 1. URL Validation and Filtering

### Validate URL Scheme

```php
function validate_url_scheme( $url ) {
	$scheme = parse_url( $url, PHP_URL_SCHEME );

	// Only allow HTTP and HTTPS
	$allowed_schemes = array( 'http', 'https' );

	if ( ! in_array( $scheme, $allowed_schemes, true ) ) {
		return new WP_Error( 'invalid_scheme', 'Only HTTP and HTTPS protocols are allowed' );
	}

	return true;
}
```

### Validate URL Format

```php
function validate_url_format( $url ) {
	// Use WordPress function
	$url = esc_url_raw( $url );

	// Validate URL structure
	if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) {
		return new WP_Error( 'invalid_url', 'Invalid URL format' );
	}

	return $url;
}
```

---

## 2. Blocking Internal IPs

### Check for Internal IPs

```php
function is_internal_ip( $ip ) {
	// Convert hostname to IP if needed
	if ( ! filter_var( $ip, FILTER_VALIDATE_IP ) ) {
		$ip = gethostbyname( $ip );
	}

	// Private IP ranges
	$private_ranges = array(
		'127.0.0.0/8',      // localhost
		'10.0.0.0/8',       // Private network
		'172.16.0.0/12',    // Private network
		'192.168.0.0/16',   // Private network
		'169.254.0.0/16',   // Link-local
		'::1',              // IPv6 localhost
		'fc00::/7',         // IPv6 private
	);

	foreach ( $private_ranges as $range ) {
		if ( ip_in_range( $ip, $range ) ) {
			return true;
		}
	}

	return false;
}

function ip_in_range( $ip, $range ) {
	if ( strpos( $range, '/' ) === false ) {
		return $ip === $range;
	}

	list( $subnet, $mask ) = explode( '/', $range );
	$ip_long = ip2long( $ip );
	$subnet_long = ip2long( $subnet );
	$mask_long = -1 << ( 32 - (int) $mask );

	return ( $ip_long & $mask_long ) === ( $subnet_long & $mask_long );
}
```

### Block Internal Hosts

```php
function block_internal_hosts( $url ) {
	$host = parse_url( $url, PHP_URL_HOST );

	// Block localhost variations
	$blocked_hosts = array(
		'localhost',
		'127.0.0.1',
		'0.0.0.0',
		'::1',
	);

	if ( in_array( strtolower( $host ), $blocked_hosts, true ) ) {
		return new WP_Error( 'blocked_host', 'Internal hosts are not allowed' );
	}

	// Check IP
	$ip = gethostbyname( $host );
	if ( is_internal_ip( $ip ) ) {
		return new WP_Error( 'blocked_ip', 'Internal IPs are not allowed' );
	}

	return true;
}
```

---

## 3. Whitelist Approach

### Domain Whitelist

```php
function validate_whitelist( $url ) {
	$host = parse_url( $url, PHP_URL_HOST );

	// Allowed domains
	$whitelist = array(
		'api.example.com',
		'cdn.example.com',
		'images.example.com',
	);

	if ( ! in_array( $host, $whitelist, true ) ) {
		return new WP_Error( 'not_whitelisted', 'Domain not in whitelist' );
	}

	return true;
}
```

### URL Pattern Whitelist

```php
function validate_url_pattern( $url ) {
	$allowed_patterns = array(
		'https://api.example.com/*',
		'https://cdn.example.com/images/*',
	);

	$matched = false;
	foreach ( $allowed_patterns as $pattern ) {
		$regex = str_replace( '*', '.*', preg_quote( $pattern, '/' ) );
		if ( preg_match( '/^' . $regex . '$/', $url ) ) {
			$matched = true;
			break;
		}
	}

	if ( ! $matched ) {
		return new WP_Error( 'pattern_mismatch', 'URL does not match allowed patterns' );
	}

	return true;
}
```

---

## 4. Safe Remote Request Function

### Complete Safe Implementation

```php
function safe_remote_get( $url, $args = array() ) {
	// 1. Validate URL format
	$url = esc_url_raw( $url );
	if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) {
		return new WP_Error( 'invalid_url', 'Invalid URL format' );
	}

	// 2. Validate scheme
	$scheme = parse_url( $url, PHP_URL_SCHEME );
	if ( ! in_array( $scheme, array( 'http', 'https' ), true ) ) {
		return new WP_Error( 'invalid_scheme', 'Only HTTP and HTTPS allowed' );
	}

	// 3. Block internal hosts
	$host = parse_url( $url, PHP_URL_HOST );
	$blocked_hosts = array( 'localhost', '127.0.0.1', '0.0.0.0', '::1' );
	if ( in_array( strtolower( $host ), $blocked_hosts, true ) ) {
		return new WP_Error( 'blocked_host', 'Internal hosts not allowed' );
	}

	// 4. Resolve and check IP
	$ip = gethostbyname( $host );
	if ( is_internal_ip( $ip ) ) {
		return new WP_Error( 'blocked_ip', 'Internal IPs not allowed' );
	}

	// 5. Block cloud metadata services
	$metadata_hosts = array(
		'169.254.169.254', // AWS, Azure, GCP
		'metadata.google.internal',
		'metadata.azure.com',
	);
	if ( in_array( strtolower( $host ), $metadata_hosts, true ) ) {
		return new WP_Error( 'metadata_blocked', 'Metadata services not allowed' );
	}

	// 6. Make request with timeout
	$default_args = array(
		'timeout' => 5,
		'redirection' => 0, // Disable redirects
	);
	$args = wp_parse_args( $args, $default_args );

	return wp_remote_get( $url, $args );
}
```

---

## 5. Blocking Cloud Metadata Services

### Specific Blocking

```php
function block_metadata_services( $url ) {
	$host = parse_url( $url, PHP_URL_HOST );

	$metadata_services = array(
		'169.254.169.254',           // AWS, Azure, GCP
		'metadata.google.internal',  // Google Cloud
		'metadata.azure.com',        // Azure
		'169.254.169.250',          // Alibaba Cloud
	);

	if ( in_array( strtolower( $host ), $metadata_services, true ) ) {
		return new WP_Error( 'metadata_blocked', 'Metadata services are blocked' );
	}

	// Also check IP
	$ip = gethostbyname( $host );
	if ( $ip === '169.254.169.254' ) {
		return new WP_Error( 'metadata_blocked', 'Metadata services are blocked' );
	}

	return true;
}
```

---

## 6. Disabling Redirects

### Prevent Redirect Attacks

```php
function safe_remote_get_no_redirects( $url ) {
	$args = array(
		'redirection' => 0, // Disable redirects
		'timeout' => 5,
	);

	return wp_remote_get( $url, $args );
}
```

Redirects can be used to bypass URL validation:
1. Initial URL passes validation
2. Server redirects to internal URL
3. Internal resource accessed

---

## 7. Host-Level Protections

### Firewall Rules

Block outbound requests to internal IPs:
```bash
# iptables example
iptables -A OUTPUT -d 127.0.0.0/8 -j DROP
iptables -A OUTPUT -d 10.0.0.0/8 -j DROP
iptables -A OUTPUT -d 192.168.0.0/16 -j DROP
iptables -A OUTPUT -d 169.254.0.0/16 -j DROP
```

### Network Segmentation

- Isolate WordPress server from internal services
- Use separate network segments
- Implement network access controls

---

## 8. WordPress-Specific Mitigations

### Filter wp_remote_get

```php
add_filter( 'http_request_args', function( $args, $url ) {
	// Validate URL before request
	$host = parse_url( $url, PHP_URL_HOST );

	if ( is_internal_host( $host ) ) {
		return new WP_Error( 'blocked', 'Internal hosts blocked' );
	}

	return $args;
}, 10, 2 );
```

### Validate in Plugins

```php
// Plugin function
function fetch_external_data( $url ) {
	// Validate before making request
	$validation = validate_url( $url );
	if ( is_wp_error( $validation ) ) {
		return $validation;
	}

	return wp_remote_get( $url );
}

function validate_url( $url ) {
	// Check scheme
	if ( ! in_array( parse_url( $url, PHP_URL_SCHEME ), array( 'http', 'https' ), true ) ) {
		return new WP_Error( 'invalid_scheme', 'Invalid scheme' );
	}

	// Check host
	$host = parse_url( $url, PHP_URL_HOST );
	if ( is_internal_host( $host ) ) {
		return new WP_Error( 'internal_host', 'Internal hosts not allowed' );
	}

	return true;
}
```

---

## 9. Best Practices Summary

### 1. Always Validate URLs
- Check URL format
- Validate scheme (only HTTP/HTTPS)
- Verify host is not internal

### 2. Block Internal IPs
- Check resolved IP addresses
- Block private IP ranges
- Block localhost variations

### 3. Use Whitelists When Possible
- Whitelist allowed domains
- Whitelist URL patterns
- More secure than blacklists

### 4. Disable Redirects
- Set `redirection => 0`
- Prevents redirect-based bypasses

### 5. Implement Timeouts
- Set reasonable timeouts
- Prevent resource exhaustion

### 6. Host-Level Protections
- Firewall rules
- Network segmentation
- Additional layer of defense

---

## Exam Tips

### Key Points to Remember

1. **URL Validation:**
   - Validate scheme (HTTP/HTTPS only)
   - Validate URL format
   - Block file:// and other protocols

2. **IP Blocking:**
   - Block private IP ranges
   - Block localhost
   - Block cloud metadata IPs

3. **Whitelist Approach:**
   - More secure than blacklist
   - Whitelist allowed domains
   - Whitelist URL patterns

4. **Additional Protections:**
   - Disable redirects
   - Set timeouts
   - Host-level firewall rules

5. **Common Mistakes:**
   - No URL validation
   - Allowing internal IPs
   - Not blocking metadata services
   - Allowing redirects

---

## Additional Resources

- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [WordPress HTTP API - WordPress Developer Resources](https://developer.wordpress.org/plugins/http-api/)
