# 8.4 Writing Scripts for Recovery and Remediation - Study Notes

## Overview

Writing scripts for database fixes and migrations during recovery is essential for efficient disaster recovery. Understanding how to safely patch or transform data, handle serialized data, repair user accounts, and restore missing content is critical for WordPress recovery operations.

**Key Reference:** [WP-CLI Commands - WordPress Developer Resources](https://wp-cli.org/commands/)

---

## 1. Writing Scripts to Patch or Transform Data

### Basic Data Transformation Script

**Template for Data Transformation:**
```php
<?php
/**
 * Data transformation script template
 *
 * Always backup before running!
 */

require_once 'wp-load.php';

global $wpdb;

// 1. Backup before transformation
$backup_file = WP_CONTENT_DIR . '/backup-before-transform-' . date( 'YmdHis' ) . '.sql';
exec( "wp db export {$backup_file}" );
echo "Backup created: {$backup_file}\n";

// 2. Find records to transform
$records_to_fix = $wpdb->get_results(
	"SELECT ID, post_title, post_content
	FROM {$wpdb->posts}
	WHERE post_type = 'post'
	   AND post_status = 'publish'
	   AND post_content LIKE '%old_pattern%'"
);

echo "Found " . count( $records_to_fix ) . " records to transform.\n";

// 3. Transform data
$updated = 0;
foreach ( $records_to_fix as $record ) {
	$new_content = str_replace( 'old_pattern', 'new_pattern', $record->post_content );

	$result = $wpdb->update(
		$wpdb->posts,
		array( 'post_content' => $new_content ),
		array( 'ID' => $record->ID )
	);

	if ( $result !== false ) {
		$updated++;
	}
}

echo "Updated {$updated} records.\n";

// 4. Verify transformation
$remaining = $wpdb->get_var(
	"SELECT COUNT(*)
	FROM {$wpdb->posts}
	WHERE post_content LIKE '%old_pattern%'"
);

if ( $remaining == 0 ) {
	echo "Transformation complete. All records updated.\n";
} else {
	echo "WARNING: {$remaining} records still contain old pattern.\n";
}
```

### Batch Data Update Script

**Safe Batch Updates:**
```php
<?php
// batch-update-posts.php

require_once 'wp-load.php';

global $wpdb;

// Configuration
$batch_size = 100;
$dry_run = true; // Set to false to actually update

// Backup
$backup_file = WP_CONTENT_DIR . '/backup-batch-update-' . date( 'YmdHis' ) . '.sql';
exec( "wp db export {$backup_file}" );
echo "Backup created: {$backup_file}\n";

// Get total count
$total = $wpdb->get_var(
	"SELECT COUNT(*)
	FROM {$wpdb->posts}
	WHERE post_type = 'post'
	   AND post_status = 'publish'"
);

echo "Total posts to process: {$total}\n";

$offset = 0;
$updated = 0;

while ( $offset < $total ) {
	// Get batch
	$posts = $wpdb->get_results(
		$wpdb->prepare(
			"SELECT ID, post_title, post_content
			FROM {$wpdb->posts}
			WHERE post_type = 'post'
			   AND post_status = 'publish'
			LIMIT %d OFFSET %d",
			$batch_size,
			$offset
		)
	);

	if ( empty( $posts ) ) {
		break;
	}

	foreach ( $posts as $post ) {
		// Transform logic
		$new_content = $post->post_content;
		// ... transformation logic ...

		if ( ! $dry_run ) {
			$wpdb->update(
				$wpdb->posts,
				array( 'post_content' => $new_content ),
				array( 'ID' => $post->ID )
			);
		}

		$updated++;
	}

	$offset += $batch_size;
	echo "Processed {$updated} / {$total} posts...\n";

	// Small delay to avoid overwhelming database
	usleep( 100000 ); // 0.1 second
}

if ( $dry_run ) {
	echo "DRY RUN: No changes made. Set \$dry_run = false to apply changes.\n";
} else {
	echo "Updated {$updated} posts.\n";
}
```

### Conditional Data Transformation

**Conditional Updates Based on Criteria:**
```php
<?php
// conditional-transform.php

require_once 'wp-load.php';

global $wpdb;

// Backup
$backup_file = WP_CONTENT_DIR . '/backup-conditional-' . date( 'YmdHis' ) . '.sql';
exec( "wp db export {$backup_file}" );

// Transform based on conditions
$posts = $wpdb->get_results(
	"SELECT ID, post_title, post_date, post_status
	FROM {$wpdb->posts}
	WHERE post_type = 'post'"
);

$updated = 0;
$skipped = 0;

foreach ( $posts as $post ) {
	$should_update = false;
	$update_data = array();

	// Condition 1: Fix old status
	if ( $post->post_status === 'old_status' ) {
		$update_data['post_status'] = 'publish';
		$should_update = true;
	}

	// Condition 2: Fix old dates
	$post_date = strtotime( $post->post_date );
	if ( $post_date < strtotime( '2020-01-01' ) ) {
		$update_data['post_date'] = date( 'Y-m-d H:i:s', strtotime( '+1 year', $post_date ) );
		$update_data['post_date_gmt'] = get_gmt_from_date( $update_data['post_date'] );
		$should_update = true;
	}

	if ( $should_update ) {
		$wpdb->update(
			$wpdb->posts,
			$update_data,
			array( 'ID' => $post->ID )
		);
		$updated++;
	} else {
		$skipped++;
	}
}

echo "Updated: {$updated}, Skipped: {$skipped}\n";
```

---

## 2. Handling Serialized Data Safely

### Understanding WordPress Serialization

**WordPress Serialization Format:**
```php
<?php
// WordPress uses PHP serialize() for:
// - Options (wp_options table)
// - Post meta (wp_postmeta table)
// - User meta (wp_usermeta table)
// - Comment meta (wp_commentmeta table)

// Example serialized data
$data = array(
	'key1' => 'value1',
	'key2' => array( 'nested' => 'data' ),
);

$serialized = serialize( $data );
// Result: a:2:{s:4:"key1";s:6:"value1";s:4:"key2";a:1:{s:6:"nested";s:4:"data";}}

// WordPress helper function
$unserialized = maybe_unserialize( $serialized );
```

### Safe Serialized Data Update

**Updating Serialized Options:**
```php
<?php
// update-serialized-option.php

require_once 'wp-load.php';

global $wpdb;

// Backup
$backup_file = WP_CONTENT_DIR . '/backup-serialized-' . date( 'YmdHis' ) . '.sql';
exec( "wp db export {$backup_file}" );

// Get serialized option
$option_value = get_option( 'my_plugin_settings' );

if ( is_array( $option_value ) ) {
	// Modify array
	$option_value['new_key'] = 'new_value';
	$option_value['existing_key'] = 'updated_value';

	// Update option (WordPress handles serialization)
	update_option( 'my_plugin_settings', $option_value );

	echo "Option updated successfully.\n";
} else {
	echo "Option is not an array or doesn't exist.\n";
}
```

### Fixing Corrupted Serialized Data

**Repair Broken Serialization:**
```php
<?php
// fix-serialized-data.php

require_once 'wp-load.php';

global $wpdb;

// Find potentially corrupted serialized data
$options = $wpdb->get_results(
	"SELECT option_name, option_value
	FROM {$wpdb->options}
	WHERE option_value LIKE 'a:%'
	   OR option_value LIKE 'O:%'"
);

$fixed = 0;

foreach ( $options as $option ) {
	if ( ! is_serialized( $option->option_value ) ) {
		continue;
	}

	$unserialized = @unserialize( $option->option_value );

	// Check if unserialize failed
	if ( false === $unserialized && $option->option_value !== serialize( false ) ) {
		// Try to fix common issues

		// 1. Remove null bytes
		$cleaned = str_replace( "\0", '', $option->option_value );

		// 2. Fix string length issues
		$cleaned = preg_replace_callback(
			'/s:(\d+):"([^"]*)"/',
			function( $matches ) {
				$length = strlen( $matches[2] );
				return "s:{$length}:\"{$matches[2]}\"";
			},
			$cleaned
		);

		$repaired = @unserialize( $cleaned );

		if ( false !== $repaired ) {
			// Update with repaired value
			update_option( $option->option_name, $repaired );
			echo "Fixed: {$option->option_name}\n";
			$fixed++;
		} else {
			// Log unfixable
			error_log( "Cannot fix serialized data: {$option->option_name}" );
		}
	}
}

echo "Fixed {$fixed} corrupted options.\n";
```

### Updating Serialized Post Meta

**Safe Post Meta Updates:**
```php
<?php
// update-serialized-post-meta.php

require_once 'wp-load.php';

global $wpdb;

// Get posts with specific meta
$posts = $wpdb->get_results(
	"SELECT p.ID, pm.meta_value
	FROM {$wpdb->posts} p
	INNER JOIN {$wpdb->postmeta} pm ON p.ID = pm.post_id
	WHERE pm.meta_key = 'my_custom_data'
	   AND pm.meta_value LIKE 'a:%'"
);

$updated = 0;

foreach ( $posts as $post ) {
	// Unserialize existing data
	$data = maybe_unserialize( $post->meta_value );

	if ( ! is_array( $data ) ) {
		continue;
	}

	// Modify data
	$data['updated_field'] = 'new_value';
	$data['timestamp'] = current_time( 'mysql' );

	// Update meta (WordPress handles serialization)
	update_post_meta( $post->ID, 'my_custom_data', $data );

	$updated++;
}

echo "Updated {$updated} post meta entries.\n";
```

---

## 3. Repairing User Accounts and Relationships

### Fix User Account Issues

**Repair Corrupted User Data:**
```php
<?php
// repair-user-accounts.php

require_once 'wp-load.php';

global $wpdb;

// Find users with issues
$problematic_users = $wpdb->get_results(
	"SELECT ID, user_login, user_email, user_registered
	FROM {$wpdb->users}
	WHERE user_login IS NULL
	   OR user_email IS NULL
	   OR user_email = ''
	   OR user_registered = '0000-00-00 00:00:00'"
);

if ( empty( $problematic_users ) ) {
	echo "No problematic users found.\n";
	exit;
}

echo "Found " . count( $problematic_users ) . " users with issues.\n";

foreach ( $problematic_users as $user ) {
	$update_data = array();

	// Fix NULL login
	if ( empty( $user->user_login ) ) {
		$update_data['user_login'] = 'user_' . $user->ID;
	}

	// Fix NULL or empty email
	if ( empty( $user->user_email ) ) {
		$update_data['user_email'] = 'user' . $user->ID . '@example.com';
	}

	// Fix invalid registration date
	if ( $user->user_registered === '0000-00-00 00:00:00' || empty( $user->user_registered ) ) {
		$update_data['user_registered'] = current_time( 'mysql' );
	}

	if ( ! empty( $update_data ) ) {
		$wpdb->update(
			$wpdb->users,
			$update_data,
			array( 'ID' => $user->ID )
		);

		echo "Fixed user ID {$user->ID}\n";
	}
}
```

### Fix User Meta Relationships

**Repair Orphaned User Meta:**
```php
<?php
// repair-user-meta.php

require_once 'wp-load.php';

global $wpdb;

// Find orphaned user meta
$orphaned_meta = $wpdb->get_results(
	"SELECT um.umeta_id, um.user_id, um.meta_key
	FROM {$wpdb->usermeta} um
	LEFT JOIN {$wpdb->users} u ON um.user_id = u.ID
	WHERE u.ID IS NULL"
);

if ( ! empty( $orphaned_meta ) ) {
	echo "Found " . count( $orphaned_meta ) . " orphaned user meta entries.\n";

	// Delete orphaned meta
	$deleted = $wpdb->query(
		"DELETE um FROM {$wpdb->usermeta} um
		LEFT JOIN {$wpdb->users} u ON um.user_id = u.ID
		WHERE u.ID IS NULL"
	);

	echo "Deleted {$deleted} orphaned user meta entries.\n";
}

// Fix missing default user meta
$users = $wpdb->get_results(
	"SELECT ID FROM {$wpdb->users}"
);

foreach ( $users as $user ) {
	// Check for required meta
	$nickname = get_user_meta( $user->ID, 'nickname', true );
	if ( empty( $nickname ) ) {
		$user_data = get_userdata( $user->ID );
		update_user_meta( $user->ID, 'nickname', $user_data->user_login );
	}

	$display_name = get_user_meta( $user->ID, 'display_name', true );
	if ( empty( $display_name ) ) {
		$user_data = get_userdata( $user->ID );
		update_user_meta( $user->ID, 'display_name', $user_data->user_login );
	}
}
```

### Restore User Capabilities

**Fix User Roles and Capabilities:**
```php
<?php
// restore-user-capabilities.php

require_once 'wp-load.php';

// Get all users
$users = get_users();

foreach ( $users as $user ) {
	// Check if user has role
	$roles = $user->roles;

	if ( empty( $roles ) ) {
		// Assign default role
		$user->set_role( 'subscriber' );
		echo "Assigned subscriber role to user ID {$user->ID}\n";
	}

	// Verify capabilities exist
	$caps = $user->allcaps;
	if ( empty( $caps ) ) {
		// Refresh capabilities
		$user->get_role_caps();
		echo "Refreshed capabilities for user ID {$user->ID}\n";
	}
}
```

---

## 4. Restoring Missing Content from Logs or External Sources

### Restore from WordPress Revisions

**Recover Content from Revisions:**
```php
<?php
// restore-from-revisions.php

require_once 'wp-load.php';

global $wpdb;

// Find posts with missing content but have revisions
$posts_to_restore = $wpdb->get_results(
	"SELECT p.ID, p.post_title, p.post_content
	FROM {$wpdb->posts} p
	WHERE p.post_type = 'post'
	   AND (p.post_content IS NULL OR p.post_content = '')
	   AND EXISTS (
		   SELECT 1 FROM {$wpdb->posts} r
		   WHERE r.post_parent = p.ID
		   AND r.post_type = 'revision'
	   )"
);

foreach ( $posts_to_restore as $post ) {
	// Get latest revision
	$revision = $wpdb->get_row(
		$wpdb->prepare(
			"SELECT post_content, post_title
			FROM {$wpdb->posts}
			WHERE post_parent = %d
			   AND post_type = 'revision'
			ORDER BY post_date DESC
			LIMIT 1",
			$post->ID
		)
	);

	if ( $revision ) {
		// Restore content from revision
		$wpdb->update(
			$wpdb->posts,
			array(
				'post_content' => $revision->post_content,
				'post_title' => $revision->post_title ?: $post->post_title,
			),
			array( 'ID' => $post->ID )
		);

		echo "Restored content for post ID {$post->ID} from revision\n";
	}
}
```

### Restore from Backup Logs

**Parse and Restore from Log Files:**
```php
<?php
// restore-from-logs.php

require_once 'wp-load.php';

$log_file = '/path/to/backup-log.txt';

if ( ! file_exists( $log_file ) ) {
	echo "Log file not found: {$log_file}\n";
	exit;
}

// Parse log file (assuming structured format)
$log_content = file_get_contents( $log_file );
$lines = explode( "\n", $log_content );

$restored = 0;

foreach ( $lines as $line ) {
	// Parse log entry (adjust format as needed)
	if ( preg_match( '/Post ID: (\d+), Title: (.+), Content: (.+)/', $line, $matches ) ) {
		$post_id = intval( $matches[1] );
		$title = $matches[2];
		$content = $matches[3];

		// Check if post exists
		$post = get_post( $post_id );

		if ( $post ) {
			// Restore if content is missing
			if ( empty( $post->post_content ) ) {
				wp_update_post( array(
					'ID' => $post_id,
					'post_title' => $title,
					'post_content' => $content,
				) );

				echo "Restored post ID {$post_id}\n";
				$restored++;
			}
		}
	}
}

echo "Restored {$restored} posts from log.\n";
```

### Restore from External API

**Fetch and Restore from External Source:**
```php
<?php
// restore-from-api.php

require_once 'wp-load.php';

// Configuration
$api_url = 'https://api.example.com/backup/posts';
$api_key = 'your-api-key';

// Fetch data from API
$response = wp_remote_get( $api_url, array(
	'headers' => array(
		'Authorization' => 'Bearer ' . $api_key,
	),
) );

if ( is_wp_error( $response ) ) {
	echo "Error fetching from API: " . $response->get_error_message() . "\n";
	exit;
}

$data = json_decode( wp_remote_retrieve_body( $response ), true );

if ( ! $data || ! isset( $data['posts'] ) ) {
	echo "Invalid API response.\n";
	exit;
}

$restored = 0;

foreach ( $data['posts'] as $post_data ) {
	// Check if post exists
	$existing_post = get_post( $post_data['id'] );

	if ( ! $existing_post ) {
		// Create new post
		$post_id = wp_insert_post( array(
			'post_title' => $post_data['title'],
			'post_content' => $post_data['content'],
			'post_status' => $post_data['status'] ?: 'publish',
			'post_date' => $post_data['date'] ?: current_time( 'mysql' ),
		) );

		if ( $post_id ) {
			echo "Created post ID {$post_id}\n";
			$restored++;
		}
	} elseif ( empty( $existing_post->post_content ) ) {
		// Restore missing content
		wp_update_post( array(
			'ID' => $post_data['id'],
			'post_content' => $post_data['content'],
		) );

		echo "Restored content for post ID {$post_data['id']}\n";
		$restored++;
	}
}

echo "Restored {$restored} posts from API.\n";
```

### Restore from Database Backup Extract

**Extract and Restore Specific Content:**
```bash
#!/bin/bash
# extract-and-restore.sh

BACKUP_FILE=$1
POST_ID=$2

if [ -z "$BACKUP_FILE" ] || [ -z "$POST_ID" ]; then
	echo "Usage: ./extract-and-restore.sh <backup-file> <post-id>"
	exit 1
fi

# Extract specific post from backup
grep -A 100 "INSERT INTO.*wp_posts.*VALUES.*($POST_ID," "$BACKUP_FILE" > "post-$POST_ID.sql"

# Extract post meta
grep "INSERT INTO.*wp_postmeta.*VALUES.*($POST_ID," "$BACKUP_FILE" > "postmeta-$POST_ID.sql"

# Restore post
wp db import "post-$POST_ID.sql"

# Restore post meta
wp db import "postmeta-$POST_ID.sql"

echo "Restored post ID $POST_ID"
```

---

## 5. Best Practices for Recovery Scripts

### Script Template with Safety Features

**Safe Recovery Script Template:**
```php
<?php
/**
 * Recovery Script Template
 *
 * Features:
 * - Automatic backup
 * - Dry run mode
 * - Logging
 * - Rollback capability
 * - Progress tracking
 */

require_once 'wp-load.php';

// Configuration
define( 'DRY_RUN', true ); // Set to false to apply changes
define( 'BATCH_SIZE', 100 );
define( 'LOG_FILE', WP_CONTENT_DIR . '/recovery-log-' . date( 'YmdHis' ) . '.txt' );

// Logging function
function recovery_log( $message ) {
	$timestamp = date( 'Y-m-d H:i:s' );
	$log_entry = "[{$timestamp}] {$message}\n";
	file_put_contents( LOG_FILE, $log_entry, FILE_APPEND );
	echo $log_entry;
}

// Backup function
function create_backup() {
	$backup_file = WP_CONTENT_DIR . '/backup-recovery-' . date( 'YmdHis' ) . '.sql';
	exec( "wp db export {$backup_file}" );
	recovery_log( "Backup created: {$backup_file}" );
	return $backup_file;
}

// Main recovery logic
function run_recovery() {
	global $wpdb;

	recovery_log( "Starting recovery process" );
	recovery_log( "DRY RUN: " . ( DRY_RUN ? 'YES' : 'NO' ) );

	// Create backup
	$backup_file = create_backup();

	// Recovery operations here
	// ...

	recovery_log( "Recovery process completed" );
	recovery_log( "Backup location: {$backup_file}" );
}

// Run recovery
run_recovery();
```

---

## Exam Tips

### Key Points to Remember

1. **Script Safety:**
   - Always backup before running scripts
   - Use dry run mode for testing
   - Log all operations
   - Implement rollback capability

2. **Serialized Data:**
   - Use `maybe_unserialize()` and `maybe_serialize()`
   - WordPress handles serialization automatically for options/meta
   - Fix string length issues in corrupted serialized data
   - Test unserialize before updating

3. **Data Transformation:**
   - Process in batches for large datasets
   - Use transactions where possible
   - Verify transformations after completion
   - Handle edge cases

4. **User Account Repair:**
   - Fix NULL/empty user data
   - Restore missing user meta
   - Reassign roles and capabilities
   - Verify user relationships

5. **Content Restoration:**
   - Use revisions to recover content
   - Parse log files for backup data
   - Fetch from external APIs if available
   - Extract from database backups

6. **Best Practices:**
   - Always backup first
   - Test on staging first
   - Log all operations
   - Verify results
   - Document changes

---

## Additional Resources

- [WP-CLI Commands - WordPress Developer Resources](https://wp-cli.org/commands/)
- [WordPress Database Class - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wpdb/)
- [WordPress Functions - WordPress Developer Resources](https://developer.wordpress.org/reference/functions/)
- Core Files:
  - `wp-includes/wp-db.php` - Database class
  - `wp-includes/functions.php` - Helper functions including `maybe_unserialize()`
