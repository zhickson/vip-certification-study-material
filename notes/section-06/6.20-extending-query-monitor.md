# 6.20 Extending Query Monitor - Study Notes

## Overview

Query Monitor can be extended with custom panels to display plugin-specific runtime information and provide targeted debug views for themes and plugins.

**Key Reference:** [Query Monitor Extending](https://github.com/johnbillion/query-monitor/wiki/Extending-Query-Monitor)

---

## 1. Creating Query Monitor Extensions

### Basic Collector

**Create Custom Collector:**
```php
<?php
/**
 * Plugin Name: My Query Monitor Extension
 */

class QM_Collector_My_Plugin extends QM_Collector {
    public $id = 'my_plugin';

    public function get_storage(): QM_Data {
        require_once __DIR__ . '/qm-data-my-plugin.php';
        return new QM_Data_My_Plugin();
    }

    public function process() {
        $this->data->my_data = get_option( 'my_plugin_data' );
        $this->data->my_count = count( get_posts( array( 'post_type' => 'my_cpt' ) ) );
    }
}

add_filter( 'qm/collectors', function( array $collectors ): array {
    $collectors['my_plugin'] = new QM_Collector_My_Plugin();
    return $collectors;
} );
```

### Data Class

**Create Data Class:**
```php
<?php
class QM_Data_My_Plugin extends QM_Data {
    public $my_data;
    public $my_count;
}
```

---

## 2. Displaying Plugin-Specific Runtime Info

### Custom Panel

**Create Output Panel:**
```php
class QM_Output_My_Plugin extends QM_Output_Html {
    public function __construct( QM_Collector $collector ) {
        parent::__construct( $collector );
        add_filter( 'qm/output/panel_menus', array( $this, 'panel_menu' ), 20 );
    }

    public function name() {
        return __( 'My Plugin', 'my-plugin' );
    }

    public function output() {
        $data = $this->collector->get_data();

        echo '<div class="qm" id="' . esc_attr( $this->collector->id() ) . '">';
        echo '<table>';
        echo '<thead>';
        echo '<tr>';
        echo '<th>' . esc_html__( 'Data', 'my-plugin' ) . '</th>';
        echo '<th>' . esc_html__( 'Value', 'my-plugin' ) . '</th>';
        echo '</tr>';
        echo '</thead>';
        echo '<tbody>';
        echo '<tr>';
        echo '<td>' . esc_html__( 'My Data', 'my-plugin' ) . '</td>';
        echo '<td>' . esc_html( $data->my_data ) . '</td>';
        echo '</tr>';
        echo '<tr>';
        echo '<td>' . esc_html__( 'Count', 'my-plugin' ) . '</td>';
        echo '<td>' . esc_html( $data->my_count ) . '</td>';
        echo '</tr>';
        echo '</tbody>';
        echo '</table>';
        echo '</div>';
    }
}

add_filter( 'qm/outputter/html', function( array $output, QM_Collectors $collectors ): array {
    $collector = $collectors->get( 'my_plugin' );
    if ( $collector ) {
        $output['my_plugin'] = new QM_Output_My_Plugin( $collector );
    }
    return $output;
}, 20, 2 );
```

---

## 3. Providing Targeted Debug Views

### Filtered Views

**Custom Filter:**
```php
class QM_Output_My_Plugin extends QM_Output_Html {
    public function output() {
        $data = $this->collector->get_data();

        // Filter by type
        $filtered = array_filter( $data->items, function( $item ) {
            return $item->type === 'error';
        } );

        // Display filtered items
        foreach ( $filtered as $item ) {
            echo '<div class="qm-item">';
            echo esc_html( $item->message );
            echo '</div>';
        }
    }
}
```

### Grouped Views

**Group by Category:**
```php
public function output() {
    $data = $this->collector->get_data();

    $grouped = array();
    foreach ( $data->items as $item ) {
        $grouped[ $item->category ][] = $item;
    }

    foreach ( $grouped as $category => $items ) {
        echo '<h3>' . esc_html( $category ) . '</h3>';
        foreach ( $items as $item ) {
            echo '<div>' . esc_html( $item->message ) . '</div>';
        }
    }
}
```

---

## Exam Tips

### Key Points to Remember

1. **Collectors:**
   - Extend `QM_Collector`
   - Implement `process()` method
   - Register with `qm/collectors` filter

2. **Output:**
   - Extend `QM_Output_Html`
   - Implement `output()` method
   - Register with `qm/outputter/html` filter

3. **Data:**
   - Create data class extending `QM_Data`
   - Store in collector's `$data` property
   - Access in output class

4. **Best Practices:**
   - Use proper escaping
   - Follow Query Monitor patterns
   - Test thoroughly
   - Document custom panels

---

## Additional Resources

- [Query Monitor Extending](https://github.com/johnbillion/query-monitor/wiki/Extending-Query-Monitor)
- [Query Monitor GitHub](https://github.com/johnbillion/query-monitor)
