# 5.14 Resolving Merge Conflicts and Maintaining History - Study Notes

## Overview

Resolving merge conflicts safely while maintaining a clean Git history is essential for collaboration. Understanding when to use merge vs rebase and how to resolve conflicts properly ensures a maintainable codebase.

**Key Reference:** [Git Branching - Merge Conflicts](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)

---

## 1. Resolving Merge Conflicts Safely

### Understanding Conflicts

Conflicts occur when Git cannot automatically merge changes:

```bash
# Conflict markers
<<<<<<< HEAD
// Current branch code
=======
// Incoming branch code
>>>>>>> feature-branch
```

### Conflict Resolution Process

```bash
# 1. Identify conflicted files
git status

# 2. Open conflicted files
# Look for conflict markers

# 3. Resolve conflicts manually
# Choose which code to keep, or combine both

# 4. Stage resolved files
git add resolved-file.php

# 5. Complete the merge
git commit
```

### Resolving Conflicts

```php
// Before (conflicted)
<<<<<<< HEAD
function get_user_data( $user_id ) {
	return get_user_meta( $user_id, 'data', true );
}
=======
function get_user_data( $user_id ) {
	$user = get_userdata( $user_id );
	return $user ? $user->data : false;
}
>>>>>>> feature-branch

// After (resolved)
function get_user_data( $user_id ) {
	$user = get_userdata( $user_id );
	if ( ! $user ) {
		return false;
	}
	// Use meta if available, fallback to user data
	$meta = get_user_meta( $user_id, 'data', true );
	return $meta ? $meta : $user->data;
}
```

### Using Merge Tools

```bash
# Configure merge tool
git config --global merge.tool vimdiff
# Or use GUI tools:
# - VS Code: code --wait
# - Meld
# - Beyond Compare

# Use merge tool
git mergetool
```

---

## 2. Understanding Rebase vs Merge

### Merge Workflow

```bash
# Merge preserves history
git checkout main
git merge feature-branch

# Creates merge commit
# History shows branch divergence and merge
```

**History:**
```
*   Merge branch 'feature-branch'
|\
| * Feature commit 2
| * Feature commit 1
* | Main commit 2
|/
* Main commit 1
```

### Rebase Workflow

```bash
# Rebase rewrites history
git checkout feature-branch
git rebase main

# Replays commits on top of main
# Linear history
```

**History:**
```
* Feature commit 2 (replayed)
* Feature commit 1 (replayed)
* Main commit 2
* Main commit 1
```

### When to Use Merge

- Public/shared branches
- Preserve exact history
- Team prefers merge commits
- Feature branches

### When to Use Rebase

- Local feature branches
- Clean linear history
- Before merging to main
- Personal branches

---

## 3. Maintaining Readable Commit Logs

### Commit Message Standards

```bash
# Conventional commits
feat: Add user authentication
fix: Resolve login bug
docs: Update README
style: Format code
refactor: Restructure admin code
test: Add unit tests
chore: Update dependencies

# Format
<type>(<scope>): <subject>

<body>

<footer>
```

### Good Commit Messages

```bash
# ✅ Good
feat(auth): Add password reset functionality

Implements password reset with email verification.
Users can now reset passwords via email link.

Closes #123

# ❌ Bad
fix stuff
update
changes
```

### Squashing Commits

```bash
# Interactive rebase to squash
git rebase -i HEAD~3

# In editor, change 'pick' to 'squash' for commits to combine
pick abc123 Initial commit
squash def456 Fix typo
squash ghi789 Add tests

# Results in one commit with combined changes
```

---

## 4. Consistent Commit History

### Commit Frequency

```bash
# ✅ Good - Logical commits
git commit -m "feat: Add user registration form"
git commit -m "feat: Add email validation"
git commit -m "test: Add registration tests"

# ❌ Bad - Too many small commits
git commit -m "Add input field"
git commit -m "Add label"
git commit -m "Add placeholder"
```

### Atomic Commits

```bash
# Each commit should be a complete, working change
# ✅ Good
git commit -m "feat: Complete user registration feature"

# Includes:
# - Form HTML
# - Validation logic
# - Database insertion
# - Error handling

# ❌ Bad - Incomplete commits
git commit -m "Add form"  # Missing validation
```

---

## 5. Supporting Rollback and Auditability

### Clear History for Rollback

```bash
# Tag releases for easy rollback
git tag -a v1.2.3 -m "Release version 1.2.3"

# Rollback to tag
git checkout v1.2.3

# Or create rollback branch
git checkout -b rollback-v1.2.2 v1.2.2
```

### Audit Trail

```bash
# View commit history
git log --oneline --graph --all

# View changes in commit
git show <commit-hash>

# View file history
git log --follow -- filename.php

# View who changed what
git blame filename.php
```

### Revert Commits

```bash
# Revert specific commit (creates new commit)
git revert <commit-hash>

# Revert merge commit
git revert -m 1 <merge-commit-hash>

# Revert range of commits
git revert <oldest-commit>..<newest-commit>
```

---

## 6. Conflict Resolution Best Practices

### Before Merging

```bash
# Update your branch first
git checkout feature-branch
git fetch origin
git rebase origin/main  # Or merge origin/main

# Resolve conflicts locally
# Test thoroughly
# Then push
```

### During Conflict Resolution

```bash
# 1. Understand both changes
# Read the conflict markers
# Understand context

# 2. Test both versions
# See which works better
# Or combine both

# 3. Resolve completely
# Remove all conflict markers
# Ensure code works

# 4. Test after resolution
# Run tests
# Manual testing
```

### After Resolution

```bash
# Verify resolution
git status  # Should show no conflicts

# Test the merge
./vendor/bin/phpunit

# Complete the merge
git commit

# Push if on shared branch
git push origin feature-branch
```

---

## 7. Advanced Conflict Resolution

### Resolving Binary File Conflicts

```bash
# For binary files, choose one version
git checkout --ours image.jpg
# Or
git checkout --theirs image.jpg

# Then stage
git add image.jpg
```

### Resolving Directory Conflicts

```bash
# If directories conflict
git rm -r old-directory
git add new-directory
git commit
```

### Aborting Merge

```bash
# If conflict resolution is too complex
git merge --abort

# Start fresh
git checkout feature-branch
git rebase origin/main
```

---

## Exam Tips

### Key Points to Remember

1. **Conflict Resolution:**
   - Identify conflicted files
   - Understand both changes
   - Resolve manually
   - Test after resolution

2. **Merge vs Rebase:**
   - Merge: Preserves history, for shared branches
   - Rebase: Linear history, for local branches
   - Don't rebase shared/public branches

3. **Commit History:**
   - Use conventional commits
   - Write clear messages
   - Keep commits atomic
   - Squash when needed

4. **Rollback:**
   - Tag releases
   - Use `git revert` for safe rollback
   - Maintain audit trail

5. **Best Practices:**
   - Update branch before merging
   - Resolve conflicts completely
   - Test after resolution
   - Maintain clean history

---

## Additional Resources

- [Git Branching - Merge Conflicts](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)
- [Git Rebase](https://git-scm.com/book/en/v2/Git-Branching-Rebasing)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [Git Best Practices](https://www.atlassian.com/git/tutorials/comparing-workflows)
