# 1.17 Interactivity API - Study Notes

## Overview

The Interactivity API is a WordPress feature that enables reactive, stateful behavior in blocks without requiring additional JavaScript frameworks. It provides a standardised way to add client-side interactivity to server-rendered blocks, combining server-rendered data with front-end interactivity.

**Key Reference:** [Interactivity API - WordPress Developer Resources](https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/)

---

## 1. Understand What the Interactivity API Is and What It Can Be Used For

### What is the Interactivity API?

The Interactivity API is a declarative system for adding interactivity to blocks using HTML data attributes. It processes directives on the server and hydrates them on the client.

**Core Implementation:**
```15:62:wordpress/wp-includes/interactivity-api/class-wp-interactivity-api.php
final class WP_Interactivity_API {
	/**
	 * Holds the mapping of directive attribute names to their processor methods.
	 *
	 * @since 6.5.0
	 * @var array
	 */
	private static $directive_processors = array(
		'data-wp-interactive'   => 'data_wp_interactive_processor',
		'data-wp-router-region' => 'data_wp_router_region_processor',
		'data-wp-context'       => 'data_wp_context_processor',
		'data-wp-bind'          => 'data_wp_bind_processor',
		'data-wp-class'         => 'data_wp_class_processor',
		'data-wp-style'         => 'data_wp_style_processor',
		'data-wp-text'          => 'data_wp_text_processor',
		/*
		 * `data-wp-each` needs to be processed in the last place because it moves
		 * the cursor to the end of the processed items to prevent them to be processed twice.
		 */
		'data-wp-each'          => 'data_wp_each_processor',
	);
```

### Use Cases

- **Interactive Components:** Buttons, toggles, modals
- **State Management:** Track and update component state
- **Dynamic Content:** Update content without page reload
- **Form Interactions:** Handle form submissions and validation
- **Navigation:** Client-side navigation for better UX

---

## 2. Enable Reactive, Stateful Behavior in Blocks

### Basic Setup

**1. Enable in block.json:**
```json
{
	"supports": {
		"interactivity": true
	}
}
```

**2. Add Interactive Directive:**
```html
<div data-wp-interactive="myNamespace">
	<!-- Interactive content -->
</div>
```

**3. Define State:**
```php
wp_interactivity_state( 'myNamespace', array(
	'isOpen' => false,
	'count' => 0,
) );
```

### Context

Use `data-wp-context` to define local state:

```html
<div data-wp-context='{ "isOpen": false, "count": 0 }'>
	<button data-wp-on--click="actions.toggle">
		Toggle
	</button>
</div>
```

**PHP Helper:**
```62:64:wordpress/wp-includes/interactivity-api/interactivity-api.php
function wp_interactivity_state( ?string $store_namespace = null, array $state = array() ): array {

}
```

---

## 3. Build Simple Client-Side Interactions Without Extra Frameworks

### Directives

**1. data-wp-bind:**
Bind attributes to state:

```html
<div data-wp-bind--hidden="context.isOpen">
	Content
</div>
```

**2. data-wp-class:**
Toggle CSS classes:

```html
<div data-wp-class--active="context.isActive">
	Item
</div>
```

**3. data-wp-style:**
Bind inline styles:

```html
<div data-wp-style--display="context.show ? 'block' : 'none'">
	Content
</div>
```

**4. data-wp-text:**
Update text content:

```html
<span data-wp-text="context.count"></span>
```

**5. data-wp-on:**
Handle events:

```html
<button data-wp-on--click="actions.increment">
	Increment
</button>
```

### Actions and Getters

Define in JavaScript:

```javascript
wp.interactivity.store( 'myNamespace', {
	actions: {
		toggle: ( { context } ) => {
			context.isOpen = !context.isOpen;
		},
		increment: ( { context } ) => {
			context.count++;
		},
	},
	getters: {
		isEven: ( { context } ) => {
			return context.count % 2 === 0;
		},
	},
} );
```

---

## 4. Combine Server-Rendered Data with Front-End Interactivity

### Server-Side Rendering

Blocks are rendered on the server with interactivity directives:

```php
function render_my_block( $attributes, $content, $block ) {
	$count = isset( $attributes['count'] ) ? $attributes['count'] : 0;

	ob_start();
	?>
	<div data-wp-interactive="myNamespace">
		<div data-wp-context='<?php echo wp_json_encode( array( 'count' => $count ) ); ?>'>
			<span data-wp-text="context.count"></span>
			<button data-wp-on--click="actions.increment">
				Increment
			</button>
		</div>
	</div>
	<?php
	return ob_get_clean();
}
```

### Hydration

The Interactivity API automatically hydrates directives on the client:

1. Server renders HTML with directives
2. Client JavaScript processes directives
3. State is initialized from server data
4. Interactions update state reactively

---

## 5. Follow Accessibility and Performance Best Practices

### Accessibility

**1. Use Semantic HTML:**
```html
<button data-wp-on--click="actions.toggle">
	Toggle Menu
</button>
```

**2. ARIA Attributes:**
```html
<div
	data-wp-bind--aria-expanded="context.isOpen"
	data-wp-bind--aria-hidden="!context.isOpen"
>
	Content
</div>
```

**3. Keyboard Navigation:**
```html
<button
	data-wp-on--click="actions.toggle"
	data-wp-on--keydown="actions.handleKeydown"
>
	Toggle
</button>
```

### Performance

**1. Lazy Load Interactive Blocks:**
```php
// Only load interactivity for visible blocks
if ( is_block_in_viewport( $block ) ) {
	wp_enqueue_script( 'interactivity-api' );
}
```

**2. Minimize State:**
```php
// ✅ GOOD - Minimal state
wp_interactivity_state( 'myNamespace', array(
	'isOpen' => false,
) );

// ❌ BAD - Large state objects
wp_interactivity_state( 'myNamespace', $large_array );
```

**3. Use Client Navigation:**
```json
{
	"supports": {
		"interactivity": {
			"clientNavigation": true
		}
	}
}
```

---

## Exam Tips

### Key Points to Remember

1. **Interactivity API:**
   - Declarative system using data attributes
   - No additional frameworks needed
   - Server-rendered with client hydration

2. **Directives:**
   - `data-wp-bind` - Bind attributes
   - `data-wp-class` - Toggle classes
   - `data-wp-text` - Update text
   - `data-wp-on` - Handle events

3. **State Management:**
   - Use `wp_interactivity_state()` for global state
   - Use `data-wp-context` for local state
   - Actions update state, getters compute values

4. **Best Practices:**
   - Follow accessibility guidelines
   - Minimize state size
   - Use semantic HTML
   - Enable client navigation for better performance

---

## Additional Resources

- [Interactivity API - WordPress Developer Resources](https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/)
- Core Files:
  - `wp-includes/interactivity-api/` - Interactivity API implementation
