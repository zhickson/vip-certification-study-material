# 7.8 Offloaded Search Services - Study Notes

## Overview

Offloading search functionality to external engines like Elasticsearch or OpenSearch provides scalable, performant search capabilities that MySQL cannot efficiently handle for large datasets. Understanding when and how to implement offloaded search is essential for high-traffic WordPress sites.

**Key Reference:** [Elasticsearch Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)

---

## 1. Integrating Elasticsearch or OpenSearch

### Why Offload Search?

**MySQL Limitations:**
- Full-text search is limited
- Complex queries are slow
- Doesn't scale well for large datasets
- Limited faceting and filtering

**Search Engine Benefits:**
- Fast full-text search
- Advanced query capabilities
- Faceted search
- Real-time indexing
- Horizontal scaling

### Elasticsearch Setup

**Installation:**
```bash
# Docker setup
docker run -d \
  --name elasticsearch \
  -p 9200:9200 \
  -p 9300:9300 \
  -e "discovery.type=single-node" \
  -e "xpack.security.enabled=false" \
  docker.elastic.co/elasticsearch/elasticsearch:8.11.0
```

**WordPress Integration:**
```php
// Install Elasticsearch PHP client
// composer require elasticsearch/elasticsearch

require_once 'vendor/autoload.php';

use Elasticsearch\ClientBuilder;

class Elasticsearch_Integration {
	private $client;

	public function __construct() {
		$hosts = array(
			get_option( 'elasticsearch_host', 'localhost:9200' ),
		);

		$this->client = ClientBuilder::create()
			->setHosts( $hosts )
			->build();
	}

	public function index_post( $post_id ) {
		$post = get_post( $post_id );

		if ( ! $post || $post->post_status !== 'publish' ) {
			$this->delete_post( $post_id );
			return;
		}

		$params = array(
			'index' => 'wordpress',
			'id' => $post_id,
			'body' => array(
				'title' => $post->post_title,
				'content' => wp_strip_all_tags( $post->post_content ),
				'excerpt' => $post->post_excerpt,
				'post_type' => $post->post_type,
				'post_date' => $post->post_date,
				'author' => get_the_author_meta( 'display_name', $post->post_author ),
				'url' => get_permalink( $post_id ),
			),
		);

		// Add categories and tags
		$categories = wp_get_post_categories( $post_id, array( 'fields' => 'names' ) );
		$tags = wp_get_post_tags( $post_id, array( 'fields' => 'names' ) );

		$params['body']['categories'] = $categories;
		$params['body']['tags'] = $tags;

		// Add custom fields
		$meta = get_post_meta( $post_id );
		$params['body']['meta'] = array();
		foreach ( $meta as $key => $values ) {
			if ( ! str_starts_with( $key, '_' ) ) {
				$params['body']['meta'][ $key ] = $values[0];
			}
		}

		$this->client->index( $params );
	}

	public function delete_post( $post_id ) {
		$this->client->delete( array(
			'index' => 'wordpress',
			'id' => $post_id,
		) );
	}

	public function search( $query, $args = array() ) {
		$defaults = array(
			'post_type' => 'post',
			'posts_per_page' => 10,
			'paged' => 1,
		);
		$args = wp_parse_args( $args, $defaults );

		$search_params = array(
			'index' => 'wordpress',
			'body' => array(
				'query' => array(
					'bool' => array(
						'must' => array(
							array(
								'multi_match' => array(
									'query' => $query,
									'fields' => array( 'title^3', 'content', 'excerpt' ),
									'type' => 'best_fields',
								),
							),
						),
						'filter' => array(
							array(
								'term' => array( 'post_type' => $args['post_type'] ),
							),
						),
					),
				),
				'from' => ( $args['paged'] - 1 ) * $args['posts_per_page'],
				'size' => $args['posts_per_page'],
			),
		);

		$response = $this->client->search( $search_params );

		// Convert to WordPress format
		$post_ids = array();
		foreach ( $response['hits']['hits'] as $hit ) {
			$post_ids[] = $hit['_id'];
		}

		return array(
			'post_ids' => $post_ids,
			'total' => $response['hits']['total']['value'],
		);
	}
}

$elasticsearch = new Elasticsearch_Integration();
```

### OpenSearch Integration

**OpenSearch Setup:**
```bash
# OpenSearch is AWS's fork of Elasticsearch
# Similar API to Elasticsearch
```

**WordPress Integration:**
```php
// OpenSearch uses same client library
// Just change the host to OpenSearch endpoint
$hosts = array(
	'https://search-domain.us-east-1.es.amazonaws.com',
);

$this->client = ClientBuilder::create()
	->setHosts( $hosts )
	->setBasicAuthentication( $username, $password )
	->build();
```

---

## 2. Indexing WordPress Content Efficiently

### Initial Indexing

**Bulk Index Posts:**
```php
function index_all_posts() {
	$elasticsearch = new Elasticsearch_Integration();
	$batch_size = 100;
	$paged = 1;

	do {
		$posts = get_posts( array(
			'posts_per_page' => $batch_size,
			'paged' => $paged,
			'post_status' => 'publish',
			'fields' => 'ids',
		) );

		foreach ( $posts as $post_id ) {
			$elasticsearch->index_post( $post_id );
		}

		$paged++;
	} while ( count( $posts ) === $batch_size );
}

// Run via WP-CLI or cron
add_action( 'wp_loaded', function() {
	if ( defined( 'WP_CLI' ) && WP_CLI ) {
		WP_CLI::add_command( 'elasticsearch index-all', function() {
			index_all_posts();
			WP_CLI::success( 'All posts indexed' );
		} );
	}
} );
```

### Incremental Indexing

**Index on Post Save:**
```php
add_action( 'save_post', function( $post_id ) {
	$elasticsearch = new Elasticsearch_Integration();
	$elasticsearch->index_post( $post_id );
} );

add_action( 'before_delete_post', function( $post_id ) {
	$elasticsearch = new Elasticsearch_Integration();
	$elasticsearch->delete_post( $post_id );
} );
```

**Index on Term Update:**
```php
add_action( 'set_object_terms', function( $object_id, $terms, $tt_ids, $taxonomy ) {
	if ( 'post' === get_post_type( $object_id ) ) {
		$elasticsearch = new Elasticsearch_Integration();
		$elasticsearch->index_post( $object_id );
	}
}, 10, 4 );
```

### Batch Indexing with Queue

**Use Background Processing:**
```php
class Search_Index_Queue {
	public function add_to_queue( $post_id, $action = 'index' ) {
		$queue = get_option( 'search_index_queue', array() );
		$queue[] = array(
			'post_id' => $post_id,
			'action' => $action,
			'timestamp' => time(),
		);
		update_option( 'search_index_queue', $queue );
	}

	public function process_queue() {
		$queue = get_option( 'search_index_queue', array() );
		$batch = array_slice( $queue, 0, 10 ); // Process 10 at a time

		$elasticsearch = new Elasticsearch_Integration();

		foreach ( $batch as $item ) {
			if ( $item['action'] === 'index' ) {
				$elasticsearch->index_post( $item['post_id'] );
			} elseif ( $item['action'] === 'delete' ) {
				$elasticsearch->delete_post( $item['post_id'] );
			}
		}

		// Remove processed items
		$queue = array_slice( $queue, 10 );
		update_option( 'search_index_queue', $queue );
	}
}

// Process queue via cron
add_action( 'wp_loaded', function() {
	if ( ! wp_next_scheduled( 'process_search_index_queue' ) ) {
		wp_schedule_event( time(), 'every_5_minutes', 'process_search_index_queue' );
	}
} );

add_action( 'process_search_index_queue', function() {
	$queue = new Search_Index_Queue();
	$queue->process_queue();
} );
```

---

## 3. Building Faceted or Full-Text Search Interfaces

### Faceted Search

**Elasticsearch Aggregations:**
```php
public function faceted_search( $query, $filters = array() ) {
	$search_params = array(
		'index' => 'wordpress',
		'body' => array(
			'query' => array(
				'multi_match' => array(
					'query' => $query,
					'fields' => array( 'title^3', 'content' ),
				),
			),
			'aggs' => array(
				'categories' => array(
					'terms' => array(
						'field' => 'categories.keyword',
						'size' => 20,
					),
				),
				'tags' => array(
					'terms' => array(
						'field' => 'tags.keyword',
						'size' => 20,
					),
				),
				'post_types' => array(
					'terms' => array(
						'field' => 'post_type.keyword',
					),
				),
				'date_range' => array(
					'date_histogram' => array(
						'field' => 'post_date',
						'calendar_interval' => 'month',
					),
				),
			),
		),
	);

	// Add filters
	if ( ! empty( $filters['categories'] ) ) {
		$search_params['body']['query']['bool']['filter'][] = array(
			'terms' => array( 'categories.keyword' => $filters['categories'] ),
		);
	}

	$response = $this->client->search( $search_params );

	return array(
		'results' => $response['hits']['hits'],
		'facets' => $response['aggregations'],
		'total' => $response['hits']['total']['value'],
	);
}
```

**Display Faceted Search:**
```php
function display_faceted_search() {
	$query = get_search_query();
	$filters = $_GET['filters'] ?? array();

	$elasticsearch = new Elasticsearch_Integration();
	$results = $elasticsearch->faceted_search( $query, $filters );

	// Display facets
	echo '<div class="facets">';
	foreach ( $results['facets'] as $facet_name => $facet_data ) {
		echo '<h3>' . esc_html( ucfirst( $facet_name ) ) . '</h3>';
		echo '<ul>';
		foreach ( $facet_data['buckets'] as $bucket ) {
			$active = in_array( $bucket['key'], $filters[ $facet_name ] ?? array() );
			$url = add_query_arg( array(
				'filters[' . $facet_name . '][]' => $bucket['key'],
			) );
			echo '<li>';
			echo '<a href="' . esc_url( $url ) . '" class="' . ( $active ? 'active' : '' ) . '">';
			echo esc_html( $bucket['key'] ) . ' (' . $bucket['doc_count'] . ')';
			echo '</a>';
			echo '</li>';
		}
		echo '</ul>';
	}
	echo '</div>';

	// Display results
	echo '<div class="results">';
	foreach ( $results['results'] as $hit ) {
		$post_id = $hit['_id'];
		$post = get_post( $post_id );
		// Display post
	}
	echo '</div>';
}
```

### Full-Text Search Features

**Advanced Search Options:**
```php
public function advanced_search( $query, $options = array() ) {
	$defaults = array(
		'fuzzy' => false,
		'highlight' => true,
		'sort' => 'relevance',
	);
	$options = wp_parse_args( $options, $defaults );

	$search_params = array(
		'index' => 'wordpress',
		'body' => array(
			'query' => array(
				'multi_match' => array(
					'query' => $query,
					'fields' => array( 'title^3', 'content', 'excerpt' ),
					'type' => 'best_fields',
					'fuzziness' => $options['fuzzy'] ? 'AUTO' : '0',
				),
			),
		),
	);

	// Add highlighting
	if ( $options['highlight'] ) {
		$search_params['body']['highlight'] = array(
			'fields' => array(
				'title' => array(),
				'content' => array(
					'fragment_size' => 150,
					'number_of_fragments' => 3,
				),
			),
		);
	}

	// Add sorting
	if ( $options['sort'] === 'date' ) {
		$search_params['body']['sort'] = array( 'post_date' => 'desc' );
	}

	return $this->client->search( $search_params );
}
```

---

## 4. Offloading Heavy Search Queries from MySQL

### Replace WordPress Search

**Override Default Search:**
```php
add_filter( 'posts_pre_query', function( $posts, $query ) {
	if ( ! $query->is_search() ) {
		return $posts;
	}

	$search_query = get_search_query();
	if ( empty( $search_query ) ) {
		return $posts;
	}

	// Use Elasticsearch instead of MySQL
	$elasticsearch = new Elasticsearch_Integration();
	$results = $elasticsearch->search( $search_query, array(
		'posts_per_page' => $query->get( 'posts_per_page' ),
		'paged' => $query->get( 'paged' ),
	) );

	// Return post IDs to prevent MySQL query
	$query->found_posts = $results['total'];
	$query->max_num_pages = ceil( $results['total'] / $query->get( 'posts_per_page' ) );

	return array_map( 'get_post', $results['post_ids'] );
}, 10, 2 );
```

### Custom Search Endpoint

**REST API Search Endpoint:**
```php
add_action( 'rest_api_init', function() {
	register_rest_route( 'wp/v2', '/search', array(
		'methods' => 'GET',
		'callback' => 'elasticsearch_rest_search',
		'permission_callback' => '__return_true',
		'args' => array(
			'q' => array(
				'required' => true,
				'type' => 'string',
			),
			'post_type' => array(
				'default' => 'post',
				'type' => 'string',
			),
			'page' => array(
				'default' => 1,
				'type' => 'integer',
			),
			'per_page' => array(
				'default' => 10,
				'type' => 'integer',
			),
		),
	) );
} );

function elasticsearch_rest_search( $request ) {
	$query = $request->get_param( 'q' );
	$post_type = $request->get_param( 'post_type' );
	$page = $request->get_param( 'page' );
	$per_page = $request->get_param( 'per_page' );

	$elasticsearch = new Elasticsearch_Integration();
	$results = $elasticsearch->search( $query, array(
		'post_type' => $post_type,
		'paged' => $page,
		'posts_per_page' => $per_page,
	) );

	$posts = array();
	foreach ( $results['post_ids'] as $post_id ) {
		$post = get_post( $post_id );
		$posts[] = array(
			'id' => $post->ID,
			'title' => $post->post_title,
			'content' => $post->post_content,
			'url' => get_permalink( $post->ID ),
		);
	}

	return new WP_REST_Response( array(
		'posts' => $posts,
		'total' => $results['total'],
		'page' => $page,
		'per_page' => $per_page,
	) );
}
```

---

## Exam Tips

### Key Points to Remember

1. **Why Offload Search:**
   - MySQL full-text search is limited
   - Complex queries are slow
   - Need for faceting and advanced features
   - Better scalability

2. **Integration:**
   - Use Elasticsearch or OpenSearch
   - Index WordPress content
   - Update index on content changes
   - Use background processing for bulk operations

3. **Indexing:**
   - Index on post save/update
   - Delete on post deletion
   - Bulk index existing content
   - Use queues for large datasets

4. **Search Features:**
   - Full-text search
   - Faceted search with aggregations
   - Highlighting
   - Fuzzy matching
   - Sorting options

5. **Implementation:**
   - Replace WordPress default search
   - Create custom REST endpoints
   - Handle pagination
   - Monitor search performance

---

## Additional Resources

- [Elasticsearch Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
- [OpenSearch Documentation](https://opensearch.org/docs/)
- [Elasticsearch PHP Client](https://www.elastic.co/guide/en/elasticsearch/client/php-api/current/index.html)
- [SearchWP Plugin](https://searchwp.com/) - WordPress search plugin with Elasticsearch support
