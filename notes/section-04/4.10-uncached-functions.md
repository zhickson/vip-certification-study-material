# 4.10 Uncached Functions - Study Notes

## Overview

Some WordPress functions query the database repeatedly without caching. Identifying these functions and implementing appropriate caching strategies is essential for performance optimization.

**Key Reference:** [WordPress Functions - WordPress Developer Resources](https://developer.wordpress.org/reference/)

---

## 1. Identifying Functions That Repeatedly Query

### Common Uncached Functions

**1. `get_term()` / `get_term_by()`:**
```php
// ❌ BAD - Queries database each time
$term = get_term( $term_id );
$term = get_term( $term_id ); // Another query!

// ✅ GOOD - WordPress caches terms
$term = get_term( $term_id );
$term = get_term( $term_id ); // From cache
```

**Note:** WordPress does cache terms, but only within a single request.

**2. `get_userdata()` / `get_user_by()`:**
```php
// ❌ BAD - Queries database each time
$user = get_userdata( $user_id );
$user = get_userdata( $user_id ); // Another query!

// ✅ GOOD - WordPress caches users
$user = get_userdata( $user_id );
$user = get_userdata( $user_id ); // From cache
```

**3. `get_post_meta()`:**
```php
// ❌ BAD - Queries database each time (without cache priming)
$meta = get_post_meta( $post_id, 'key', true );
$meta = get_post_meta( $post_id, 'key', true ); // Another query!

// ✅ GOOD - Prime cache first
update_postmeta_cache( array( $post_id ) );
$meta = get_post_meta( $post_id, 'key', true );
$meta = get_post_meta( $post_id, 'key', true ); // From cache
```

**4. `get_option()`:**
```php
// ❌ BAD - Queries database for non-autoloaded options
$option = get_option( 'my_plugin_setting' );
$option = get_option( 'my_plugin_setting' ); // Another query!

// ✅ GOOD - WordPress caches within request
$option = get_option( 'my_plugin_setting' );
$option = get_option( 'my_plugin_setting' ); // From cache
```

**5. `get_post()`:**
```php
// WordPress caches posts, but can be improved
$post = get_post( $post_id );
$post = get_post( $post_id ); // From cache
```

---

## 2. Functions That Need Manual Caching

### Custom Functions

**Example - Expensive Calculation:**
```php
// ❌ BAD - No caching
function get_post_view_count( $post_id ) {
	global $wpdb;

	$count = $wpdb->get_var( $wpdb->prepare(
		"SELECT COUNT(*) FROM {$wpdb->postmeta}
		WHERE post_id = %d AND meta_key = 'view'",
		$post_id
	) );

	return $count;
}

// Called multiple times
get_post_view_count( 123 ); // Query 1
get_post_view_count( 123 ); // Query 2
get_post_view_count( 123 ); // Query 3
```

**With Caching:**
```php
// ✅ GOOD - With caching
function get_post_view_count( $post_id ) {
	$cache_key = 'post_view_count_' . $post_id;
	$count = wp_cache_get( $cache_key );

	if ( false === $count ) {
		global $wpdb;

		$count = $wpdb->get_var( $wpdb->prepare(
			"SELECT COUNT(*) FROM {$wpdb->postmeta}
			WHERE post_id = %d AND meta_key = 'view'",
			$post_id
		) );

		wp_cache_set( $cache_key, $count, '', 3600 );
	}

	return $count;
}
```

### Database Queries

**Direct Queries:**
```php
// ❌ BAD - No caching
function get_featured_products() {
	global $wpdb;

	return $wpdb->get_results(
		"SELECT * FROM {$wpdb->posts}
		WHERE post_type = 'product'
		AND ID IN (
			SELECT post_id FROM {$wpdb->postmeta}
			WHERE meta_key = 'featured' AND meta_value = 'yes'
		)"
	);
}
```

**With Caching:**
```php
// ✅ GOOD - With caching
function get_featured_products() {
	$cache_key = 'featured_products';
	$products = wp_cache_get( $cache_key );

	if ( false === $products ) {
		global $wpdb;

		$products = $wpdb->get_results(
			"SELECT * FROM {$wpdb->posts}
			WHERE post_type = 'product'
			AND ID IN (
				SELECT post_id FROM {$wpdb->postmeta}
				WHERE meta_key = 'featured' AND meta_value = 'yes'
			)"
		);

		wp_cache_set( $cache_key, $products, '', 3600 );
	}

	return $products;
}
```

---

## 3. Caching Results Where Appropriate

### Object Cache

**Using `wp_cache_get()` / `wp_cache_set()`:**
```php
function get_expensive_data( $key ) {
	$cache_key = 'expensive_data_' . md5( $key );
	$data = wp_cache_get( $cache_key );

	if ( false === $data ) {
		// Expensive operation
		$data = perform_expensive_operation( $key );

		// Cache for 1 hour
		wp_cache_set( $cache_key, $data, '', 3600 );
	}

	return $data;
}
```

### Transients

**For Temporary Data:**
```php
function get_api_data() {
	$transient_key = 'api_data';
	$data = get_transient( $transient_key );

	if ( false === $data ) {
		// Fetch from API
		$response = wp_remote_get( 'https://api.example.com/data' );
		$data = json_decode( wp_remote_retrieve_body( $response ), true );

		// Cache for 1 hour
		set_transient( $transient_key, $data, HOUR_IN_SECONDS );
	}

	return $data;
}
```

### Prime Caches

**Batch Loading:**
```php
// ❌ BAD - Multiple queries
foreach ( $post_ids as $post_id ) {
	$meta = get_post_meta( $post_id, 'price', true ); // Query each time
}

// ✅ GOOD - Prime cache
update_postmeta_cache( $post_ids );

foreach ( $post_ids as $post_id ) {
	$meta = get_post_meta( $post_id, 'price', true ); // From cache
}
```

**Term Cache:**
```php
// Prime term cache
$term_ids = array( 1, 2, 3, 4, 5 );
update_term_cache( $term_ids );

// Now get_term() uses cache
foreach ( $term_ids as $term_id ) {
	$term = get_term( $term_id ); // From cache
}
```

---

## 4. Replacing Uncached Calls with Efficient Patterns

### Use WordPress APIs

**Instead of Direct Queries:**
```php
// ❌ BAD - Direct query
function get_published_posts() {
	global $wpdb;
	return $wpdb->get_results(
		"SELECT * FROM {$wpdb->posts}
		WHERE post_status = 'publish'"
	);
}
```

**Use WP_Query:**
```php
// ✅ GOOD - Uses WordPress caching
function get_published_posts() {
	$query = new WP_Query( array(
		'post_status' => 'publish',
		'posts_per_page' => -1,
	) );
	return $query->posts;
}
```

### Batch Operations

**Instead of Loops:**
```php
// ❌ BAD - Multiple queries in loop
foreach ( $post_ids as $post_id ) {
	$post = get_post( $post_id );
	$meta = get_post_meta( $post_id, 'key', true );
	$terms = wp_get_post_terms( $post_id, 'category' );
}
```

**Batch Load:**
```php
// ✅ GOOD - Batch load
update_post_caches( $posts );
update_postmeta_cache( $post_ids );

foreach ( $post_ids as $post_id ) {
	$post = get_post( $post_id ); // From cache
	$meta = get_post_meta( $post_id, 'key', true ); // From cache
	$terms = wp_get_post_terms( $post_id, 'category' ); // From cache
}
```

### Use Filters

**Cache Filter Results:**
```php
// ❌ BAD - Expensive filter called multiple times
add_filter( 'the_content', function( $content ) {
	// Expensive operation
	$processed = expensive_processing( $content );
	return $processed;
} );
```

**Cache Results:**
```php
// ✅ GOOD - Cache filter results
add_filter( 'the_content', function( $content ) {
	$cache_key = 'processed_content_' . md5( $content );
	$processed = wp_cache_get( $cache_key );

	if ( false === $processed ) {
		$processed = expensive_processing( $content );
		wp_cache_set( $cache_key, $processed, '', 3600 );
	}

	return $processed;
} );
```

---

## 5. Common Uncached Patterns

### N+1 Query Problem

**Problem:**
```php
// ❌ BAD - N+1 queries
$posts = get_posts( array( 'posts_per_page' => 10 ) );

foreach ( $posts as $post ) {
	$author = get_userdata( $post->post_author ); // Query for each post
	$meta = get_post_meta( $post->ID, 'key', true ); // Query for each post
}
// Total: 1 + 10 + 10 = 21 queries
```

**Solution:**
```php
// ✅ GOOD - Batch load
$posts = get_posts( array( 'posts_per_page' => 10 ) );

$post_ids = wp_list_pluck( $posts, 'ID' );
$author_ids = array_unique( wp_list_pluck( $posts, 'post_author' ) );

// Prime caches
update_postmeta_cache( $post_ids );
cache_users( $author_ids );

foreach ( $posts as $post ) {
	$author = get_userdata( $post->post_author ); // From cache
	$meta = get_post_meta( $post->ID, 'key', true ); // From cache
}
// Total: 1 + 1 + 1 = 3 queries
```

### Repeated Function Calls

**Problem:**
```php
// ❌ BAD - Called multiple times
function render_post( $post_id ) {
	$post = get_post( $post_id );
	$author = get_userdata( $post->post_author );
	$categories = wp_get_post_categories( $post_id );
	// ... more calls
}

render_post( 123 ); // Multiple queries
render_post( 123 ); // Same queries again
```

**Solution:**
```php
// ✅ GOOD - Cache at function level
function render_post( $post_id ) {
	static $cache = array();

	if ( isset( $cache[ $post_id ] ) ) {
		return $cache[ $post_id ];
	}

	$post = get_post( $post_id );
	$author = get_userdata( $post->post_author );
	$categories = wp_get_post_categories( $post_id );

	$cache[ $post_id ] = compact( 'post', 'author', 'categories' );

	return $cache[ $post_id ];
}
```

---

## Exam Tips

### Key Points to Remember

1. **Identify Uncached Functions:**
   - Functions that query database
   - Functions called in loops
   - Expensive calculations
   - External API calls

2. **Caching Strategies:**
   - Use `wp_cache_get()` / `wp_cache_set()` for object cache
   - Use transients for temporary data
   - Prime caches for batch operations
   - Cache filter results

3. **Best Practices:**
   - Prime caches before loops
   - Use WordPress APIs instead of direct queries
   - Batch load related data
   - Cache expensive operations

4. **Common Patterns:**
   - N+1 query problems
   - Repeated function calls
   - Unbounded queries
   - Missing cache priming

5. **WordPress Functions:**
   - `update_postmeta_cache()` - Prime post meta
   - `update_term_cache()` - Prime terms
   - `update_post_caches()` - Prime posts
   - `wp_cache_get()` / `wp_cache_set()` - Object cache

---

## Additional Resources

- [WordPress Functions - WordPress Developer Resources](https://developer.wordpress.org/reference/)
- [Object Cache - WordPress Developer Resources](https://developer.wordpress.org/reference/functions/wp_cache_get/)
- [Transients API - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/transients/)
- Core Files:
  - `wp-includes/cache.php` - Cache functions
  - `wp-includes/meta.php` - Meta functions with caching
