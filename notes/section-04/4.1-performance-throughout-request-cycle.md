# 4.1 Performance Throughout the Request Cycle - Study Notes

## Overview

Understanding how performance is affected from DNS resolution to browser rendering is crucial for optimizing WordPress sites. The WordPress execution lifecycle involves multiple stages, each with potential bottlenecks.

**Key Reference:** [WordPress Execution Flow - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/wordpress/execution-flow/)

---

## 1. WordPress Execution Lifecycle

### Request Flow Stages

**1. DNS Resolution**
- Browser resolves domain name to IP address
- Cached by DNS servers and browser
- Impact: First-time visitors may experience DNS lookup delay

**2. Server Connection**
- TCP handshake and SSL negotiation (if HTTPS)
- Impact: Network latency, SSL handshake overhead

**3. WordPress Bootstrap**
- `index.php` → `wp-blog-header.php` → `wp-load.php` → `wp-settings.php`
- Loads core files, plugins, themes
- Impact: File I/O, autoloaded options, plugin initialization

**4. Query Parsing**
- WordPress parses request URL
- Determines query variables and template hierarchy
- Impact: Rewrite rule matching, query construction

**5. Database Queries**
- Main query execution
- Secondary queries (meta, terms, users)
- Impact: Query complexity, index usage, database load

**6. Template Rendering**
- Template file selection and execution
- Hook execution (actions and filters)
- Impact: PHP execution time, hook overhead

**7. Response Delivery**
- Output buffering and compression
- HTTP headers
- Impact: Response size, compression, headers

**8. Browser Rendering**
- HTML parsing, CSS/JS loading
- Impact: Asset size, render-blocking resources

### Core Bootstrap Sequence

```1:21:wordpress/wp-blog-header.php
<?php
/**
 * Loads the WordPress environment and template.
 *
 * @package WordPress
 */

if ( ! isset( $wp_did_header ) ) {

	$wp_did_header = true;

	// Load the WordPress library.
	require_once __DIR__ . '/wp-load.php';

	// Set up the WordPress query.
	wp();

	// Load the theme template.
	require_once ABSPATH . WPINC . '/template-loader.php';

}
```

**Execution Order:**
1. `wp-load.php` - Loads WordPress core
2. `wp()` - Parses request and sets up query
3. `template-loader.php` - Loads appropriate template

---

## 2. Identifying Bottlenecks at Each Stage

### Server-Side Bottlenecks

#### PHP Execution Time

**Common Causes:**
- Expensive operations in hooks
- Unbounded queries
- Large autoloaded options
- Inefficient template code

**Measurement:**
```php
// Start timer
timer_start();

// Your code here

// Get elapsed time
$elapsed = timer_stop();
error_log( "Execution time: {$elapsed} seconds" );
```

**WordPress Timer:**
```82:82:wordpress/wp-settings.php
timer_start();
```

#### Database Queries

**Common Issues:**
- N+1 query problems
- Missing indexes
- Unbounded queries
- Expensive meta queries

**Debugging:**
```php
// Enable query logging
define( 'SAVEQUERIES', true );

// After page load, inspect queries
global $wpdb;
foreach ( $wpdb->queries as $query ) {
	error_log( $query[0] . ' - ' . $query[1] );
}
```

#### Memory Usage

**Common Causes:**
- Large autoloaded options
- Loading too many posts
- Memory leaks in plugins

**Monitoring:**
```php
// Check memory usage
$memory_usage = memory_get_usage( true );
$memory_peak = memory_get_peak_usage( true );

error_log( "Current: " . size_format( $memory_usage ) );
error_log( "Peak: " . size_format( $memory_peak ) );
```

### Database Bottlenecks

#### Query Performance

**Slow Query Indicators:**
- Full table scans
- Missing indexes
- Complex JOINs
- Large result sets

**Optimization:**
- Use `EXPLAIN` to analyze queries
- Add appropriate indexes
- Limit result sets
- Use query caching

#### Connection Pooling

**Issues:**
- Too many concurrent connections
- Long-running queries blocking connections
- Connection timeouts

**Solutions:**
- Use persistent connections carefully
- Optimize query execution time
- Implement connection pooling at server level

### Front-End Bottlenecks

#### Asset Loading

**Common Issues:**
- Render-blocking CSS/JS
- Large unoptimized images
- Too many HTTP requests
- Missing compression

**Optimization:**
```php
// Defer non-critical JavaScript
function defer_scripts( $tag, $handle, $src ) {
	if ( 'my-non-critical-script' === $handle ) {
		return str_replace( ' src', ' defer src', $tag );
	}
	return $tag;
}
add_filter( 'script_loader_tag', 'defer_scripts', 10, 3 );
```

#### Render Performance

**Issues:**
- Large DOM trees
- Expensive JavaScript execution
- Layout thrashing
- Unoptimized images

---

## 3. Optimizing Server-Side Performance

### Reduce Bootstrap Overhead

**1. Minimize Autoloaded Options**
```php
// Check autoloaded options size
$autoloaded = wp_load_alloptions();
$size = strlen( serialize( $autoloaded ) );

if ( $size > 800000 ) { // 800KB threshold
	error_log( "Large autoloaded options: " . size_format( $size ) );
}
```

**2. Lazy Load Plugin Code**
```php
// ✅ GOOD - Load only when needed
if ( is_admin() ) {
	require_once plugin_dir_path( __FILE__ ) . 'admin/admin.php';
}

// ❌ BAD - Load everything on every request
require_once plugin_dir_path( __FILE__ ) . 'admin/admin.php';
```

**3. Use Appropriate Hooks**
```php
// ✅ GOOD - Hook only in frontend
if ( ! is_admin() ) {
	add_action( 'wp', 'my_frontend_handler' );
}

// ❌ BAD - Hook runs everywhere
add_action( 'init', 'my_handler' ); // Runs in admin, AJAX, REST API
```

### Optimize Database Queries

**1. Limit Query Results**
```php
// ✅ GOOD
$args = array(
	'posts_per_page' => 10,
	'no_found_rows' => true, // Skip pagination count
);

// ❌ BAD
$args = array(
	'posts_per_page' => -1, // Gets all posts
);
```

**2. Use Query Caching**
```php
// Cache expensive queries
$cache_key = 'my_expensive_query_' . md5( serialize( $args ) );
$results = wp_cache_get( $cache_key );

if ( false === $results ) {
	$query = new WP_Query( $args );
	$results = $query->posts;
	wp_cache_set( $cache_key, $results, '', 3600 );
}
```

**3. Prime Caches**
```php
// Prime post meta cache
update_postmeta_cache( $post_ids );

// Prime term cache
update_object_term_cache( $post_ids, 'post' );
```

### Optimize Template Rendering

**1. Use Output Buffering Wisely**
```php
// ✅ GOOD - Cache expensive template parts
ob_start();
get_template_part( 'expensive-template' );
$cached = ob_get_clean();

wp_cache_set( 'template_part', $cached, '', 3600 );
echo $cached;
```

**2. Minimize Hook Overhead**
```php
// ✅ GOOD - Conditional hook execution
if ( is_singular() ) {
	add_filter( 'the_content', 'my_content_filter' );
}

// ❌ BAD - Hook always runs
add_filter( 'the_content', 'my_content_filter' );
```

---

## 4. Optimizing Client-Side Performance

### Asset Optimization

**1. Minify and Concatenate**
```php
// Use WordPress minification
wp_enqueue_script( 'my-script', 'script.js', array(), '1.0.0', true );
// WordPress handles minification in production
```

**2. Use CDN for Static Assets**
```php
// Serve assets from CDN
function cdn_asset_url( $url ) {
	if ( defined( 'CDN_URL' ) ) {
		return str_replace( home_url(), CDN_URL, $url );
	}
	return $url;
}
add_filter( 'style_loader_src', 'cdn_asset_url' );
add_filter( 'script_loader_src', 'cdn_asset_url' );
```

**3. Lazy Load Images**
```php
// Add loading="lazy" to images
function add_lazy_loading( $attr, $attachment, $size ) {
	$attr['loading'] = 'lazy';
	return $attr;
}
add_filter( 'wp_get_attachment_image_attributes', 'add_lazy_loading', 10, 3 );
```

### Reduce Render-Blocking Resources

**1. Defer JavaScript**
```php
function defer_parsing_of_js( $url ) {
	if ( is_admin() ) {
		return $url;
	}
	if ( false === strpos( $url, '.js' ) ) {
		return $url;
	}
	if ( strpos( $url, 'jquery.js' ) ) {
		return $url;
	}
	return str_replace( ' src', ' defer src', $url );
}
add_filter( 'script_loader_tag', 'defer_parsing_of_js', 10 );
```

**2. Inline Critical CSS**
```php
// Extract and inline critical CSS
function inline_critical_css() {
	$critical_css = file_get_contents( get_template_directory() . '/critical.css' );
	echo '<style>' . $critical_css . '</style>';
}
add_action( 'wp_head', 'inline_critical_css', 1 );
```

---

## 5. Performance Measurement Tools

### Server-Side Profiling

**1. Query Monitor Plugin**
- Shows all database queries
- Displays hook execution
- Tracks HTTP requests
- Measures execution time

**2. Xdebug Profiling**
```ini
; php.ini
xdebug.profiler_enable = 1
xdebug.profiler_output_dir = /tmp
```

**3. Custom Timing**
```php
function profile_function( $function_name ) {
	$start = microtime( true );
	// Function execution
	$end = microtime( true );
	error_log( "{$function_name}: " . ( $end - $start ) . "s" );
}
```

### Client-Side Profiling

**1. Browser DevTools**
- Network tab: Request timing
- Performance tab: Rendering performance
- Lighthouse: Overall performance score

**2. WebPageTest**
- Real-world performance testing
- Waterfall charts
- Filmstrip view

**3. Google PageSpeed Insights**
- Performance score
- Core Web Vitals
- Optimization suggestions

---

## Exam Tips

### Key Points to Remember

1. **Request Lifecycle Stages:**
   - DNS → Connection → Bootstrap → Query → Template → Response → Rendering

2. **Common Bottlenecks:**
   - Large autoloaded options
   - Unbounded queries
   - Missing indexes
   - Render-blocking resources

3. **Optimization Strategies:**
   - Minimize bootstrap overhead
   - Cache expensive operations
   - Optimize database queries
   - Defer non-critical assets

4. **Measurement:**
   - Use Query Monitor for server-side
   - Use browser DevTools for client-side
   - Monitor Core Web Vitals

5. **Performance Budget:**
   - Time to First Byte (TTFB): < 200ms
   - First Contentful Paint (FCP): < 1.8s
   - Largest Contentful Paint (LCP): < 2.5s

---

## Additional Resources

- [WordPress Execution Flow - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/wordpress/execution-flow/)
- [Performance Best Practices - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/performance/optimization/)
- [Query Monitor Plugin](https://wordpress.org/plugins/query-monitor/)
- [Web Vitals - Google Developers](https://web.dev/vitals/)
- Core Files:
  - `wp-blog-header.php` - Entry point
  - `wp-load.php` - Bootstrap loader
  - `wp-settings.php` - Core initialization
  - `wp-includes/template-loader.php` - Template selection
