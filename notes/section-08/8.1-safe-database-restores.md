# 8.1 Safe Database Restores - Study Notes

## Overview

Safe database restoration is critical for disaster recovery. Understanding how to restore full or partial WordPress databases without causing data loss or integrity issues is essential for maintaining site stability.

**Key Reference:** [WordPress Backups - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/backup/)

---

## 1. Restoring Databases with WP-CLI

### Full Database Restore

**Basic Restore:**
```bash
# Restore from SQL file
wp db import backup.sql

# Restore from compressed backup
gunzip -c backup.sql.gz | wp db import -

# Restore with progress output
wp db import backup.sql --debug
```

**Safe Restore Process:**
```bash
#!/bin/bash
# safe-restore.sh

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
	echo "Usage: ./safe-restore.sh <backup-file>"
	exit 1
fi

# 1. Backup current database first
echo "Creating backup of current database..."
wp db export backup-before-restore-$(date +%Y%m%d-%H%M%S).sql

# 2. Verify backup file exists and is readable
if [ ! -f "$BACKUP_FILE" ]; then
	echo "Error: Backup file not found: $BACKUP_FILE"
	exit 1
fi

# 3. Check database connection
if ! wp db check; then
	echo "Error: Database connection failed"
	exit 1
fi

# 4. Restore database
echo "Restoring database from $BACKUP_FILE..."
if [[ "$BACKUP_FILE" == *.gz ]]; then
	gunzip -c "$BACKUP_FILE" | wp db import -
else
	wp db import "$BACKUP_FILE"
fi

# 5. Verify restore
if wp db check; then
	echo "Database restore completed successfully"
else
	echo "Error: Database restore failed"
	exit 1
fi
```

### Partial Table Restore

**Restore Specific Tables:**
```bash
# Extract specific tables from backup
grep -E "^CREATE TABLE.*wp_posts|^INSERT INTO.*wp_posts|^LOCK TABLES.*wp_posts|^UNLOCK TABLES" backup.sql > wp_posts_restore.sql

# Restore specific table
wp db import wp_posts_restore.sql

# Or use sed to extract table
sed -n '/CREATE TABLE.*wp_posts/,/UNLOCK TABLES/p' backup.sql > wp_posts_restore.sql
wp db import wp_posts_restore.sql
```

**Selective Restore Script:**
```bash
#!/bin/bash
# restore-tables.sh

BACKUP_FILE=$1
TABLES=$2

if [ -z "$BACKUP_FILE" ] || [ -z "$TABLES" ]; then
	echo "Usage: ./restore-tables.sh <backup-file> <table1,table2,...>"
	exit 1
fi

# Backup current state
wp db export backup-before-partial-restore-$(date +%Y%m%d).sql

# Extract tables
TEMP_DIR=$(mktemp -d)
IFS=',' read -ra TABLE_ARRAY <<< "$TABLES"

for table in "${TABLE_ARRAY[@]}"; do
	echo "Extracting table: $table"
	grep -E "^CREATE TABLE.*$table|^INSERT INTO.*$table|^LOCK TABLES.*$table|^UNLOCK TABLES" "$BACKUP_FILE" > "$TEMP_DIR/${table}.sql"
done

# Restore tables
for table in "${TABLE_ARRAY[@]}"; do
	echo "Restoring table: $table"
	wp db import "$TEMP_DIR/${table}.sql"
done

rm -rf "$TEMP_DIR"
echo "Partial restore complete"
```

---

## 2. Restoring with phpMyAdmin

### Full Database Restore via phpMyAdmin

**Steps:**
1. Access phpMyAdmin
2. Select the WordPress database
3. Click "Import" tab
4. Choose backup file
5. Set character set (usually `utf8mb4`)
6. Click "Go"

**Important Considerations:**
- Maximum file size limits (check `upload_max_filesize` and `post_max_size` in PHP)
- For large databases, use command line instead
- Ensure proper character set encoding

### Partial Restore via phpMyAdmin

**Restore Specific Table:**
1. Select database
2. Click on table name
3. Click "Operations" tab
4. Use "Import" or manually run SQL

**Manual SQL Execution:**
```sql
-- Drop existing table (backup first!)
DROP TABLE IF EXISTS wp_posts_backup;
CREATE TABLE wp_posts_backup AS SELECT * FROM wp_posts;

-- Restore from backup
SOURCE /path/to/backup.sql;
```

---

## 3. Restoring with SQL Commands

### Direct MySQL/MariaDB Restore

**Command Line Restore:**
```bash
# Restore with MySQL client
mysql -u username -p database_name < backup.sql

# Restore compressed backup
gunzip < backup.sql.gz | mysql -u username -p database_name

# Restore with specific character set
mysql -u username -p --default-character-set=utf8mb4 database_name < backup.sql
```

**Interactive MySQL Restore:**
```bash
mysql -u username -p

# In MySQL prompt
USE database_name;
SOURCE /path/to/backup.sql;
EXIT;
```

### Restore with Verification

```bash
#!/bin/bash
# sql-restore.sh

DB_NAME=$(wp config get DB_NAME)
DB_USER=$(wp config get DB_USER)
DB_PASS=$(wp config get DB_PASSWORD)
BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
	echo "Usage: ./sql-restore.sh <backup-file>"
	exit 1
fi

# Backup current database
mysqldump -u "$DB_USER" -p"$DB_PASS" "$DB_NAME" > backup-before-restore-$(date +%Y%m%d).sql

# Restore
if [[ "$BACKUP_FILE" == *.gz ]]; then
	gunzip -c "$BACKUP_FILE" | mysql -u "$DB_USER" -p"$DB_PASS" "$DB_NAME"
else
	mysql -u "$DB_USER" -p"$DB_PASS" "$DB_NAME" < "$BACKUP_FILE"
fi

# Verify
if mysql -u "$DB_USER" -p"$DB_PASS" -e "USE $DB_NAME; SHOW TABLES;" | grep -q "wp_posts"; then
	echo "Restore verified: wp_posts table exists"
else
	echo "Error: Restore verification failed"
	exit 1
fi
```

---

## 4. Ensuring Schema Compatibility

### Check WordPress Version Compatibility

```bash
# Check current WordPress version
wp core version

# Check database version
wp option get db_version

# Verify schema matches
wp core verify-checksums
```

**Schema Compatibility Script:**
```bash
#!/bin/bash
# check-schema-compatibility.sh

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
	echo "Usage: ./check-schema-compatibility.sh <backup-file>"
	exit 1
fi

# Extract WordPress version from backup
WP_VERSION=$(grep -oP "option_value.*wp_version.*'\K[^']+" "$BACKUP_FILE" | head -1)
DB_VERSION=$(grep -oP "option_value.*db_version.*'\K[^']+" "$BACKUP_FILE" | head -1)

echo "Backup WordPress version: $WP_VERSION"
echo "Backup database version: $DB_VERSION"

# Check current versions
CURRENT_WP=$(wp core version)
CURRENT_DB=$(wp option get db_version)

echo "Current WordPress version: $CURRENT_WP"
echo "Current database version: $CURRENT_DB"

# Warn if versions differ significantly
if [ "$WP_VERSION" != "$CURRENT_WP" ]; then
	echo "WARNING: WordPress versions differ. Consider updating database after restore."
	echo "Run: wp core update-db"
fi
```

### Handle Database Updates After Restore

```bash
# After restoring older backup, update database schema
wp core update-db

# Check for required updates
wp core update-db --dry-run

# Force update if needed
wp core update-db --network
```

---

## 5. Avoiding Data Loss During Restore

### Pre-Restore Backup

**Always Backup Before Restore:**
```bash
#!/bin/bash
# safe-restore-with-backup.sh

BACKUP_FILE=$1

# Create timestamped backup
BACKUP_NAME="backup-before-restore-$(date +%Y%m%d-%H%M%S)"

# Full backup
wp db export "$BACKUP_NAME.sql"
tar -czf "$BACKUP_NAME-files.tar.gz" wp-content/

# Store backup location
echo "$BACKUP_NAME" > last-backup-before-restore.txt

# Now proceed with restore
wp db import "$BACKUP_FILE"
```

### Incremental Backup Strategy

```bash
# Keep multiple backups
BACKUP_DIR="/var/backups/wordpress"
mkdir -p "$BACKUP_DIR"

# Pre-restore backup
wp db export "$BACKUP_DIR/pre-restore-$(date +%Y%m%d-%H%M%S).sql"

# Restore
wp db import "$BACKUP_FILE"

# If restore fails, restore the pre-restore backup
# wp db import "$BACKUP_DIR/pre-restore-*.sql"
```

### Dry Run Restore

```bash
#!/bin/bash
# dry-run-restore.sh

BACKUP_FILE=$1
TEST_DB="wordpress_test_restore"

# Create test database
wp db create "$TEST_DB"

# Restore to test database
mysql -u root -p "$TEST_DB" < "$BACKUP_FILE"

# Verify restore
if mysql -u root -p -e "USE $TEST_DB; SHOW TABLES;" | grep -q "wp_posts"; then
	echo "Dry run successful. Proceed with actual restore?"
	read -p "Continue? (yes/no): " confirm
	if [ "$confirm" = "yes" ]; then
		wp db import "$BACKUP_FILE"
	fi
fi

# Cleanup test database
wp db drop "$TEST_DB" --yes
```

---

## 6. Validating Data Integrity Post-Restore

### Integrity Checks

**Basic Verification:**
```bash
# Check database connection
wp db check

# Verify core tables exist
wp db query "SHOW TABLES LIKE 'wp_%'"

# Count records
wp db query "SELECT COUNT(*) as post_count FROM wp_posts"
wp db query "SELECT COUNT(*) as user_count FROM wp_users"
```

**Comprehensive Integrity Check:**
```bash
#!/bin/bash
# verify-restore.sh

echo "Verifying database restore..."

# Check database connection
if ! wp db check; then
	echo "ERROR: Database connection failed"
	exit 1
fi

# Check core tables
CORE_TABLES=("wp_posts" "wp_users" "wp_options" "wp_terms" "wp_comments")

for table in "${CORE_TABLES[@]}"; do
	if wp db query "SHOW TABLES LIKE '$table'" | grep -q "$table"; then
		echo "✓ Table $table exists"
	else
		echo "✗ ERROR: Table $table missing"
		exit 1
	fi
done

# Check for orphaned meta
ORPHANED_META=$(wp db query "SELECT COUNT(*) FROM wp_postmeta pm LEFT JOIN wp_posts p ON pm.post_id = p.ID WHERE p.ID IS NULL" --skip-column-names)

if [ "$ORPHANED_META" -gt 0 ]; then
	echo "WARNING: Found $ORPHANED_META orphaned post meta entries"
else
	echo "✓ No orphaned post meta found"
fi

# Check for orphaned term relationships
ORPHANED_TERMS=$(wp db query "SELECT COUNT(*) FROM wp_term_relationships tr LEFT JOIN wp_posts p ON tr.object_id = p.ID WHERE p.ID IS NULL" --skip-column-names)

if [ "$ORPHANED_TERMS" -gt 0 ]; then
	echo "WARNING: Found $ORPHANED_TERMS orphaned term relationships"
else
	echo "✓ No orphaned term relationships found"
fi

# Verify site URL
SITE_URL=$(wp option get siteurl)
echo "Site URL: $SITE_URL"

# Test WordPress functionality
if wp core verify-checksums; then
	echo "✓ WordPress core checksums verified"
else
	echo "WARNING: Core checksum verification failed"
fi

echo "Restore verification complete"
```

### Check Serialized Data Integrity

```php
<?php
// verify-serialized-data.php

require_once 'wp-load.php';

global $wpdb;

// Check for broken serialized data in options
$broken_options = $wpdb->get_results(
	"SELECT option_name, option_value
	FROM {$wpdb->options}
	WHERE option_value LIKE 'a:%'
	OR option_value LIKE 'O:%'"
);

foreach ( $broken_options as $option ) {
	if ( ! is_serialized( $option->option_value ) ) {
		continue;
	}

	$unserialized = @unserialize( $option->option_value );
	if ( false === $unserialized && $option->option_value !== serialize( false ) ) {
		echo "ERROR: Broken serialized data in option: {$option->option_name}\n";
	}
}

// Check post meta
$broken_meta = $wpdb->get_results(
	"SELECT meta_id, post_id, meta_key, meta_value
	FROM {$wpdb->postmeta}
	WHERE meta_value LIKE 'a:%'
	OR meta_value LIKE 'O:%'"
);

foreach ( $broken_meta as $meta ) {
	if ( ! is_serialized( $meta->meta_value ) ) {
		continue;
	}

	$unserialized = @unserialize( $meta->meta_value );
	if ( false === $unserialized && $meta->meta_value !== serialize( false ) ) {
		echo "ERROR: Broken serialized data in post meta: post_id={$meta->post_id}, meta_key={$meta->meta_key}\n";
	}
}
```

---

## 7. Handling Large Database Restores

### Split Large Backups

```bash
# Split large SQL file
split -l 10000 backup.sql backup_part_

# Restore split files
for file in backup_part_*; do
	echo "Restoring $file..."
	wp db import "$file"
done
```

### Restore with Timeout Handling

```bash
#!/bin/bash
# restore-large-db.sh

BACKUP_FILE=$1
MAX_EXECUTION_TIME=3600  # 1 hour

# Increase PHP execution time
php -d max_execution_time=$MAX_EXECUTION_TIME -r "
	require 'wp-load.php';
	global \$wpdb;

	\$sql = file_get_contents('$BACKUP_FILE');
	\$wpdb->query(\$sql);
"
```

### Use MySQL Direct Import for Large Files

```bash
# For very large databases, use MySQL directly
mysql -u username -p database_name < backup.sql

# With progress monitoring
pv backup.sql | mysql -u username -p database_name

# With connection timeout
mysql -u username -p --connect-timeout=60 database_name < backup.sql
```

---

## Exam Tips

### Key Points to Remember

1. **Always Backup Before Restore:**
   - Create backup of current state
   - Store backup in safe location
   - Document backup location

2. **Restore Methods:**
   - WP-CLI: `wp db import`
   - phpMyAdmin: Import tab
   - MySQL command line: `mysql < backup.sql`

3. **Schema Compatibility:**
   - Check WordPress version compatibility
   - Run `wp core update-db` after restore if needed
   - Verify database version matches

4. **Data Integrity:**
   - Verify core tables exist
   - Check for orphaned meta/relationships
   - Validate serialized data
   - Test WordPress functionality

5. **Large Database Handling:**
   - Split large files
   - Increase execution timeouts
   - Use MySQL direct import
   - Monitor progress

6. **Safety Practices:**
   - Always backup current state first
   - Test restore on staging first
   - Verify restore before going live
   - Document restore process

---

## Additional Resources

- [WordPress Backups - WordPress Developer Resources](https://developer.wordpress.org/advanced-administration/backup/)
- [WP-CLI Database Commands](https://wp-cli.org/commands/db/)
- [MySQL Documentation - Restoring Data](https://dev.mysql.com/doc/refman/8.0/en/backup-and-recovery.html)
- [phpMyAdmin Documentation](https://www.phpmyadmin.net/docs/)
- Core Files:
  - `wp-admin/includes/upgrade.php` - Database upgrade functions
  - `wp-includes/wp-db.php` - Database class
