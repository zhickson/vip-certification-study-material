# 3.6 Roles and Capabilities System for Least Privilege - Study Notes

## Overview

WordPress uses a role-based access control (RBAC) system with capabilities. Understanding how to create, modify, and use roles and capabilities securely is essential for implementing least privilege access control.

**Key Reference:** [Roles and Capabilities - WordPress Developer Resources](https://developer.wordpress.org/plugins/security/checking-user-capabilities/)

---

## 1. Understanding Roles and Capabilities

### Roles vs Capabilities

- **Roles** - Collections of capabilities assigned to users
- **Capabilities** - Specific permissions (e.g., `edit_posts`, `delete_users`)
- **Meta Capabilities** - Dynamic capabilities mapped based on context (e.g., `edit_post`)

### Core Roles

WordPress includes these default roles:

1. **Administrator** - Full access
2. **Editor** - Can publish and manage posts
3. **Author** - Can publish and manage own posts
4. **Contributor** - Can write but not publish posts
5. **Subscriber** - Can only read

---

## 2. Creating Custom Roles

### Programmatic Role Creation

```php
function create_custom_role() {
	// Check if role exists
	if ( ! get_role( 'content_manager' ) ) {
		// Create role with base capabilities
		add_role(
			'content_manager',
			'Content Manager',
			array(
				'read' => true,
				'edit_posts' => true,
				'edit_others_posts' => true,
				'publish_posts' => true,
				'delete_posts' => true,
				'delete_others_posts' => true,
			)
		);
	}
}
add_action( 'init', 'create_custom_role' );
```

### Best Practices for Role Creation

1. **Grant Minimum Required Capabilities:**
```php
// ✅ GOOD - Minimal capabilities
add_role(
	'custom_role',
	'Custom Role',
	array(
		'read' => true,
		'edit_posts' => true,
	)
);

// ❌ BAD - Too many capabilities
add_role(
	'custom_role',
	'Custom Role',
	array(
		'read' => true,
		'edit_posts' => true,
		'manage_options' => true, // Unnecessary!
		'activate_plugins' => true, // Unnecessary!
	)
);
```

2. **Check if Role Exists:**
```php
if ( ! get_role( 'my_role' ) ) {
	add_role( 'my_role', 'My Role', $capabilities );
}
```

---

## 3. Modifying Existing Roles

### Adding Capabilities to Role

```php
function add_capabilities_to_role() {
	$role = get_role( 'editor' );
	if ( $role ) {
		$role->add_cap( 'manage_custom_feature' );
	}
}
add_action( 'init', 'add_capabilities_to_role' );
```

### Removing Capabilities from Role

```php
function remove_capabilities_from_role() {
	$role = get_role( 'editor' );
	if ( $role ) {
		$role->remove_cap( 'manage_custom_feature' );
	}
}
```

### Modifying User Capabilities Directly

```php
// Add capability to specific user
$user = new WP_User( $user_id );
$user->add_cap( 'custom_capability' );

// Remove capability from specific user
$user->remove_cap( 'custom_capability' );
```

---

## 4. Securing Custom Post Types with Capabilities

### Registering CPT with Capabilities

```php
function register_secure_cpt() {
	$args = array(
		'public' => true,
		'label' => 'Products',
		'capability_type' => 'product',
		'map_meta_cap' => true, // Important!
		'capabilities' => array(
			'edit_post' => 'edit_product',
			'read_post' => 'read_product',
			'delete_post' => 'delete_product',
			'edit_posts' => 'edit_products',
			'edit_others_posts' => 'edit_others_products',
			'publish_posts' => 'publish_products',
			'read_private_posts' => 'read_private_products',
		),
	);
	register_post_type( 'product', $args );
}
add_action( 'init', 'register_secure_cpt' );
```

### Using map_meta_cap()

The `map_meta_cap` filter allows customizing how meta capabilities are mapped:

```php
function map_custom_meta_cap( $caps, $cap, $user_id, $args ) {
	// Handle custom meta capability
	if ( 'edit_product' === $cap ) {
		$post_id = isset( $args[0] ) ? $args[0] : 0;
		$post = get_post( $post_id );

		if ( ! $post ) {
			$caps[] = 'do_not_allow';
			return $caps;
		}

		// Map to primitive capabilities
		if ( (int) $post->post_author === $user_id ) {
			$caps[] = 'edit_products';
		} else {
			$caps[] = 'edit_others_products';
		}

		if ( 'publish' === $post->post_status ) {
			$caps[] = 'edit_published_products';
		}
	}

	return $caps;
}
add_filter( 'map_meta_cap', 'map_custom_meta_cap', 10, 4 );
```

---

## 5. Securing REST API Endpoints

### Using permission_callback

```php
register_rest_route( 'myplugin/v1', '/products', array(
	'methods' => 'POST',
	'permission_callback' => function( $request ) {
		// Check capability
		return current_user_can( 'edit_products' );
	},
	'callback' => function( $request ) {
		// Process request
		return new WP_REST_Response( array( 'success' => true ) );
	},
) );
```

### Object-Specific Permissions

```php
register_rest_route( 'myplugin/v1', '/products/(?P<id>\d+)', array(
	'methods' => 'PUT',
	'permission_callback' => function( $request ) {
		$post_id = (int) $request['id'];
		return current_user_can( 'edit_product', $post_id );
	},
	'callback' => function( $request ) {
		$post_id = (int) $request['id'];
		// Update product
		return new WP_REST_Response( array( 'success' => true ) );
	},
) );
```

---

## 6. Avoiding Unnecessary Admin Access

### Common Mistake: Granting manage_options

```php
// ❌ BAD - Granting admin access unnecessarily
function grant_admin_access() {
	$role = get_role( 'editor' );
	if ( $role ) {
		$role->add_cap( 'manage_options' ); // Too much!
	}
}

// ✅ GOOD - Grant specific capability
function grant_specific_access() {
	$role = get_role( 'editor' );
	if ( $role ) {
		$role->add_cap( 'edit_products' ); // Specific
	}
}
```

### Principle: Grant Minimum Required

```php
// Determine what capability is actually needed
// For editing posts: edit_posts
// For managing settings: manage_options (only if needed)
// For activating plugins: activate_plugins (rarely needed)
```

---

## 7. Storing Security Logic

### Avoid Database Storage for Critical Logic

```php
// ❌ BAD - Storing critical security logic in database
$allowed = get_option( 'allowed_users' );
if ( in_array( $user_id, $allowed, true ) ) {
	// Security logic in database
}

// ✅ GOOD - Programmatic security logic
if ( current_user_can( 'edit_products' ) ) {
	// Security logic in code
}
```

### Use Capabilities, Not Options

```php
// ❌ BAD
$can_edit = get_user_meta( $user_id, 'can_edit_products', true );
if ( $can_edit ) {
	// Logic
}

// ✅ GOOD
if ( current_user_can( 'edit_products' ) ) {
	// Logic
}
```

---

## 8. Role and Capability Management

### Safe Role Creation on Activation

```php
function my_plugin_activate() {
	// Create role
	if ( ! get_role( 'custom_role' ) ) {
		add_role(
			'custom_role',
			'Custom Role',
			array(
				'read' => true,
				'edit_posts' => true,
			)
		);
	}

	// Add capabilities to existing roles
	$editor = get_role( 'editor' );
	if ( $editor ) {
		$editor->add_cap( 'manage_custom_feature' );
	}
}
register_activation_hook( __FILE__, 'my_plugin_activate' );
```

### Safe Role Cleanup on Deactivation

```php
function my_plugin_deactivate() {
	// Remove capabilities from roles
	$editor = get_role( 'editor' );
	if ( $editor ) {
		$editor->remove_cap( 'manage_custom_feature' );
	}

	// Note: Don't delete custom roles on deactivation
	// Users may still be using them
}
register_deactivation_hook( __FILE__, 'my_plugin_deactivate' );
```

### Safe Role Cleanup on Uninstall

```php
function my_plugin_uninstall() {
	// Remove custom role
	remove_role( 'custom_role' );

	// Remove capabilities from all roles
	$roles = wp_roles()->get_names();
	foreach ( $roles as $role_name => $role_label ) {
		$role = get_role( $role_name );
		if ( $role ) {
			$role->remove_cap( 'manage_custom_feature' );
		}
	}
}
register_uninstall_hook( __FILE__, 'my_plugin_uninstall' );
```

---

## 9. Best Practices

### 1. Use Capabilities, Not Roles

```php
// ✅ GOOD
if ( current_user_can( 'edit_posts' ) ) {
	// Action
}

// ❌ BAD
$user = wp_get_current_user();
if ( in_array( 'editor', $user->roles, true ) ) {
	// Action
}
```

### 2. Grant Minimum Required Capabilities

```php
// Only grant what's necessary
add_role(
	'role_name',
	'Role Label',
	array(
		'read' => true,
		'edit_posts' => true, // Only if needed
	)
);
```

### 3. Use map_meta_cap for CPTs

```php
register_post_type( 'product', array(
	'capability_type' => 'product',
	'map_meta_cap' => true, // Essential!
) );
```

### 4. Check Capabilities Before Actions

```php
if ( ! current_user_can( 'edit_product', $post_id ) ) {
	wp_die( 'Permission denied' );
}
// Proceed with action
```

### 5. Avoid Storing Security Logic in Database

```php
// Use capabilities, not options/user meta for security
if ( current_user_can( 'capability' ) ) {
	// Not: if ( get_option( 'allow_user' ) )
}
```

---

## Exam Tips

### Key Points to Remember

1. **Roles vs Capabilities:**
   - Roles are collections of capabilities
   - Always check capabilities, not roles
   - Use meta capabilities for object-specific checks

2. **Creating Roles:**
   - Grant minimum required capabilities
   - Check if role exists before creating
   - Use `add_role()` programmatically

3. **Securing CPTs:**
   - Set `map_meta_cap => true`
   - Define capability_type
   - Use `map_meta_cap` filter for custom logic

4. **REST API Security:**
   - Always use `permission_callback`
   - Check capabilities, not roles
   - Use object-specific checks when needed

5. **Common Mistakes:**
   - Granting `manage_options` unnecessarily
   - Storing security logic in database
   - Checking roles instead of capabilities
   - Not using `map_meta_cap` for CPTs

---

## Additional Resources

- [Roles and Capabilities - WordPress Developer Resources](https://developer.wordpress.org/plugins/security/checking-user-capabilities/)
- [Register Post Type - WordPress Developer Resources](https://developer.wordpress.org/reference/functions/register_post_type/)
- [REST API Handbook - WordPress Developer Resources](https://developer.wordpress.org/rest-api/)
- Core Files:
  - `wp-includes/capabilities.php` - Capability system
  - `wp-includes/user.php` - User and role functions
