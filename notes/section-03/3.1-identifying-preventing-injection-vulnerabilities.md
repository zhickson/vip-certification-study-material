# 3.1 Identifying and Preventing Injection Vulnerabilities - Study Notes

## Overview

Injection vulnerabilities occur when untrusted data is interpreted as code or commands. In WordPress, the three main types are SQL injection, XSS (Cross-Site Scripting), and command injection. Understanding how to identify and prevent these vulnerabilities is critical for secure WordPress development.

**Key Reference:** [Data Validation - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/validation/)

---

## 1. SQL Injection

### What is SQL Injection?

SQL injection occurs when user input is directly concatenated into SQL queries without proper sanitization or prepared statements, allowing attackers to execute arbitrary SQL commands.

### Common Attack Vectors

#### Direct Database Queries

```php
// ❌ BAD - Vulnerable to SQL injection
global $wpdb;
$user_id = $_GET['id'];
$result = $wpdb->get_results( "SELECT * FROM {$wpdb->users} WHERE ID = $user_id" );

// ✅ GOOD - Use wpdb::prepare()
$user_id = absint( $_GET['id'] );
$result = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM {$wpdb->users} WHERE ID = %d", $user_id ) );
```

#### Unsanitized Meta Queries

```php
// ❌ BAD - User input directly in meta_query
$meta_key = $_GET['key'];
$args = array(
	'meta_query' => array(
		array(
			'key' => $meta_key, // Unsafe!
			'value' => 'some_value',
		),
	),
);
$query = new WP_Query( $args );

// ✅ GOOD - Sanitize meta key
$meta_key = sanitize_key( $_GET['key'] );
$args = array(
	'meta_query' => array(
		array(
			'key' => $meta_key,
			'value' => sanitize_text_field( $_GET['value'] ),
		),
	),
);
$query = new WP_Query( $args );
```

### WordPress Prepared Statements

WordPress provides `wpdb::prepare()` for safe SQL queries:

```1401:1466:wordpress/wp-includes/class-wpdb.php
	/**
	 * Prepares a SQL query for safe execution.
	 *
	 * Uses `sprintf()`-like syntax. The following placeholders can be used in the query string:
	 *
	 * - `%d` (integer)
	 * - `%f` (float)
	 * - `%s` (string)
	 * - `%i` (identifier, e.g. table/field names)
	 *
	 * All placeholders MUST be left unquoted in the query string. A corresponding argument
	 * MUST be passed for each placeholder.
	 *
	 * Note: There is one exception to the above: for compatibility with old behavior,
	 * numbered or formatted string placeholders (eg, `%1$s`, `%5s`) will not have quotes
	 * added by this function, so should be passed with appropriate quotes around them.
	 *
	 * Literal percentage signs (`%`) in the query string must be written as `%%`. Percentage wildcards
	 * (for example, to use in LIKE syntax) must be passed via a substitution argument containing
	 * the complete LIKE string, these cannot be inserted directly in the query string.
	 * Also see wpdb::esc_like().
	 *
	 * Arguments may be passed as individual arguments to the method, or as a single array
	 * containing all arguments. A combination of the two is not supported.
	 *
	 * Examples:
	 *
	 *     $wpdb->prepare(
	 *         "SELECT * FROM `table` WHERE `column` = %s AND `field` = %d OR `other_field` LIKE %s",
	 *         array( 'foo', 1337, '%bar' )
	 *     );
	 *
	 *     $wpdb->prepare(
	 *         "SELECT DATE_FORMAT(`field`, '%%c') FROM `table` WHERE `column` = %s",
	 *         'foo'
	 *     );
	 *
	 *     $wpdb->prepare(
	 *         "SELECT * FROM %i WHERE %i = %s",
	 *         $table,
	 *         $field,
	 *         $value
	 *     );
	 *
	 * @since 2.3.0
	 * @since 5.3.0 Formalized the existing and already documented `...$args` parameter
	 *              by updating the function signature. The second parameter was changed
	 *              from `$args` to `...$args`.
	 * @since 6.2.0 Added `%i` for identifiers, e.g. table or field names.
	 *              Check support via `wpdb::has_cap( 'identifier_placeholders' )`.
	 *              This preserves compatibility with `sprintf()`, as the C version uses
	 *              `%d` and `$i` as a signed integer, whereas PHP only supports `%d`.
	 *
	 * @link https://www.php.net/sprintf Description of syntax.
	 *
	 * @param string      $query   Query statement with `sprintf()`-like placeholders.
	 * @param array|mixed $args    The array of variables to substitute into the query's placeholders
	 *                             if being called with an array of arguments, or the first variable
	 *                             to substitute into the query's placeholders if being called with
	 *                             individual arguments.
	 * @param mixed       ...$args Further variables to substitute into the query's placeholders
	 *                             if being called with individual arguments.
	 * @return string|void Sanitized query string, if there is a query to prepare.
	 */
	public function prepare( $query, ...$args ) {
		if ( is_null( $query ) ) {
			return;
		}

		/*
		 * This is not meant to be foolproof -- but it will catch obviously incorrect usage.
		 *
		 * Note: str_contains() is not used here, as this file can be included
		 * directly outside of WordPress core, e.g. by HyperDB, in which case
		 * the polyfills from wp-includes/compat.php are not loaded.
		 */
		if ( false === strpos( $query, '%' ) ) {
			wp_load_translations_early();
			_doing_it_wrong(
				'wpdb::prepare',
				sprintf(
					/* translators: %s: wpdb::prepare() */
					__( 'The query argument of %s must have a placeholder.' ),
					'wpdb::prepare()'
				),
				'3.9.0'
			);
		}
```

### Best Practices

1. **Always use `wpdb::prepare()` for custom queries:**
```php
global $wpdb;
$post_id = absint( $_GET['post_id'] );
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE ID = %d AND post_status = %s",
	$post_id,
	'publish'
);
```

2. **Use `esc_like()` for LIKE queries:**
```1768:1793:wordpress/wp-includes/class-wpdb.php
	/**
	 * First half of escaping for `LIKE` special characters `%` and `_` before preparing for SQL.
	 *
	 * Use this only before wpdb::prepare() or esc_sql(). Reversing the order is very bad for security.
	 *
	 * Example Prepared Statement:
	 *
	 *     $wild = '%';
	 *     $find = 'only 43% of planets';
	 *     $like = $wild . $wpdb->esc_like( $find ) . $wild;
	 *     $sql  = $wpdb->prepare( "SELECT * FROM $wpdb->posts WHERE post_content LIKE %s", $like );
	 *
	 * Example Escape Chain:
	 *
	 *     $sql  = esc_sql( $wpdb->esc_like( $input ) );
	 *
	 * @since 4.0.0
	 *
	 * @param string $text The raw text to be escaped. The input typed by the user
	 *                     should have no extra or deleted slashes.
	 * @return string Text in the form of a LIKE phrase. The output is not SQL safe.
	 *                Call wpdb::prepare() or wpdb::_real_escape() next.
	 */
	public function esc_like( $text ) {
		return addcslashes( $text, '_%\\' );
	}
```

```php
// Correct usage for LIKE queries
$search = $wpdb->esc_like( $_GET['search'] );
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
	'%' . $search . '%'
);
```

3. **Use identifier placeholders for table/field names (WP 6.2+):**
```php
// For table/field names, use %i placeholder
$table_name = 'wp_posts';
$field_name = 'post_title';
$query = $wpdb->prepare(
	"SELECT * FROM %i WHERE %i = %s",
	$table_name,
	$field_name,
	$value
);
```

---

## 2. XSS (Cross-Site Scripting)

### What is XSS?

XSS occurs when untrusted data is output to the browser without proper escaping, allowing attackers to inject malicious JavaScript.

### Types of XSS

#### Stored XSS
Malicious script is stored in the database and executed when displayed.

```php
// ❌ BAD - No escaping
echo $_GET['message'];

// ✅ GOOD - Escape for HTML context
echo esc_html( $_GET['message'] );
```

#### Reflected XSS
Malicious script is reflected in the response without being stored.

```php
// ❌ BAD
echo '<div>' . $_GET['name'] . '</div>';

// ✅ GOOD
echo '<div>' . esc_html( $_GET['name'] ) . '</div>';
```

#### DOM-based XSS
Malicious script manipulates the DOM on the client side.

```javascript
// ❌ BAD - Direct DOM manipulation with user input
document.getElementById('output').innerHTML = userInput;

// ✅ GOOD - Use textContent or escape
document.getElementById('output').textContent = userInput;
```

### Context-Specific Escaping

Different output contexts require different escaping functions:

#### HTML Context
```4689:4704:wordpress/wp-includes/formatting.php
function esc_html( $text ) {
	$safe_text = wp_check_invalid_utf8( $text );
	$safe_text = _wp_specialchars( $safe_text, ENT_QUOTES );
	/**
	 * Filters a string cleaned and escaped for output in HTML.
	 *
	 * Text passed to esc_html() is stripped of invalid or special characters
	 * before output.
	 *
	 * @since 2.8.0
	 *
	 * @param string $safe_text The text after it has been escaped.
	 * @param string $text      The text prior to being escaped.
	 */
	return apply_filters( 'esc_html', $safe_text, $text );
}
```

```php
// Escape for HTML body content
echo esc_html( $user_input );
```

#### HTML Attribute Context
```4714:4729:wordpress/wp-includes/formatting.php
function esc_attr( $text ) {
	$safe_text = wp_check_invalid_utf8( $text );
	$safe_text = _wp_specialchars( $safe_text, ENT_QUOTES );
	/**
	 * Filters a string cleaned and escaped for output in an HTML attribute.
	 *
	 * Text passed to esc_attr() is stripped of invalid or special characters
	 * before output.
	 *
	 * @since 2.0.6
	 *
	 * @param string $safe_text The text after it has been escaped.
	 * @param string $text      The text prior to being escaped.
	 */
	return apply_filters( 'attribute_escape', $safe_text, $text );
}
```

```php
// Escape for HTML attributes
echo '<input value="' . esc_attr( $user_input ) . '">';
```

#### URL Context
```php
// Escape for URLs
echo '<a href="' . esc_url( $user_url ) . '">Link</a>';
```

#### JavaScript Context
```php
// Escape for JavaScript
echo '<script>var name = ' . wp_json_encode( $user_input ) . ';</script>';
```

#### Allowed HTML (wp_kses)
For content that should allow some HTML tags:

```2495:2497:wordpress/wp-includes/kses.php
function wp_kses_post( $data ) {
	return wp_kses( $data, 'post' );
}
```

```php
// Allow post content HTML
$content = wp_kses_post( $user_content );
```

---

## 3. Command Injection

### What is Command Injection?

Command injection occurs when user input is passed to system commands (like `exec()`, `system()`, `shell_exec()`) without proper sanitization.

### Common Attack Vectors

```php
// ❌ BAD - Direct command execution
$filename = $_GET['file'];
exec( "cat $filename" );

// ✅ GOOD - Use WordPress functions instead
$filename = sanitize_file_name( $_GET['file'] );
$file_path = get_attached_file( $attachment_id );
// Use WordPress file handling functions
```

### Best Practices

1. **Avoid system commands entirely** - Use WordPress APIs instead
2. **If you must use system commands:**
   - Use `escapeshellarg()` and `escapeshellcmd()`
   - Validate input against whitelist
   - Run with least privileges

```php
// If absolutely necessary
$filename = escapeshellarg( sanitize_file_name( $_GET['file'] ) );
exec( "cat $filename" );
```

---

## 4. Recognizing Common Injection Vectors

### Unsanitized Meta Queries

```php
// ❌ BAD
$args = array(
	'meta_query' => array(
		array(
			'key' => $_GET['meta_key'], // Unsafe!
			'value' => $_GET['meta_value'], // Unsafe!
		),
	),
);

// ✅ GOOD
$args = array(
	'meta_query' => array(
		array(
			'key' => sanitize_key( $_GET['meta_key'] ),
			'value' => sanitize_text_field( $_GET['meta_value'] ),
		),
	),
);
```

### Direct Database Queries

```php
// ❌ BAD - String concatenation
global $wpdb;
$query = "SELECT * FROM {$wpdb->posts} WHERE post_title = '" . $_GET['title'] . "'";

// ✅ GOOD - Prepared statement
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE post_title = %s",
	sanitize_text_field( $_GET['title'] )
);
```

### Unescaped Output

```php
// ❌ BAD
echo $_POST['content'];
echo '<div>' . $user_data . '</div>';

// ✅ GOOD
echo esc_html( $_POST['content'] );
echo '<div>' . esc_html( $user_data ) . '</div>';
```

---

## Exam Tips

### Key Points to Remember

1. **SQL Injection Prevention:**
   - Always use `wpdb::prepare()` for custom queries
   - Use `esc_like()` before `prepare()` for LIKE queries
   - Sanitize meta_query keys with `sanitize_key()`
   - Use `%i` placeholder for identifiers (WP 6.2+)

2. **XSS Prevention:**
   - Escape all output based on context
   - Use `esc_html()` for HTML body
   - Use `esc_attr()` for HTML attributes
   - Use `esc_url()` for URLs
   - Use `wp_json_encode()` for JavaScript
   - Use `wp_kses_post()` for allowed HTML

3. **Command Injection Prevention:**
   - Avoid system commands when possible
   - Use WordPress file handling APIs
   - If necessary, use `escapeshellarg()` and validate input

4. **Common Mistakes:**
   - Concatenating user input into SQL queries
   - Outputting user data without escaping
   - Using `$_GET`/`$_POST` directly without sanitization
   - Trusting data from the database (it may have been stored unsafely)

---

## Additional Resources

- [Data Validation - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/validation/)
- [Data Sanitization/Escaping - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/security/data-sanitization-escaping/)
- [SQL Injection - OWASP](https://owasp.org/www-community/attacks/SQL_Injection)
- [Cross Site Scripting (XSS) - OWASP](https://owasp.org/www-community/attacks/xss/)
- Core Files:
  - `wp-includes/class-wpdb.php` - Database abstraction and prepared statements
  - `wp-includes/formatting.php` - Escaping functions
  - `wp-includes/kses.php` - HTML sanitization
