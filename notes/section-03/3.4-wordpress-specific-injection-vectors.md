# 3.4 WordPress-Specific Injection Vectors - Study Notes

## Overview

WordPress has specific areas where injection vulnerabilities commonly occur. Understanding these vectors helps identify and prevent security issues in WordPress code.

**Key Reference:** [Data Validation - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/validation/)

---

## 1. WP_Query and Meta Query Vulnerabilities

### Unsafe Meta Query Patterns

#### Unsanitized Meta Keys

```php
// ❌ BAD - User input directly in meta_query
$args = array(
	'meta_query' => array(
		array(
			'key' => $_GET['meta_key'], // Vulnerable!
			'value' => $_GET['meta_value'],
		),
	),
);
$query = new WP_Query( $args );

// ✅ GOOD - Sanitize meta key
$meta_key = sanitize_key( $_GET['meta_key'] );
$meta_value = sanitize_text_field( $_GET['meta_value'] );

$args = array(
	'meta_query' => array(
		array(
			'key' => $meta_key,
			'value' => $meta_value,
		),
	),
);
$query = new WP_Query( $args );
```

#### Unsanitized Meta Values

```php
// ❌ BAD - Unsanitized meta value
$args = array(
	'meta_query' => array(
		array(
			'key' => 'custom_field',
			'value' => $_GET['search'], // Vulnerable!
			'compare' => 'LIKE',
		),
	),
);

// ✅ GOOD - Sanitize meta value
$search = sanitize_text_field( $_GET['search'] );
$args = array(
	'meta_query' => array(
		array(
			'key' => 'custom_field',
			'value' => $search,
			'compare' => 'LIKE',
		),
	),
);
```

### How WP_Meta_Query Handles Values

WordPress uses prepared statements internally, but meta keys must still be sanitized:

```753:757:wordpress/wp-includes/class-wp-meta-query.php
				case 'LIKE':
				case 'NOT LIKE':
					$meta_value = '%' . $wpdb->esc_like( $meta_value ) . '%';
					$where      = $wpdb->prepare( '%s', $meta_value );
					break;
```

**Important:** While WordPress handles meta values safely, meta keys must be sanitized with `sanitize_key()`.

### Search Parameter Vulnerabilities

WordPress search uses `esc_like()` and prepared statements:

```1503:1509:wordpress/wp-includes/class-wp-query.php
			if ( $n && ! $exclude ) {
				$like                                 = '%' . $wpdb->esc_like( $term ) . '%';
				$query_vars['search_orderby_title'][] = $wpdb->prepare( "{$wpdb->posts}.post_title LIKE %s", $like );
			}

			$like = $n . $wpdb->esc_like( $term ) . $n;
```

**However**, if you're building custom search queries, you must sanitize:

```php
// ❌ BAD - Direct search usage without sanitization
$search = $_GET['s'];
$args = array(
	's' => $search, // May be safe, but validate anyway
);

// ✅ GOOD - Sanitize search input
$search = sanitize_text_field( $_GET['s'] );
$args = array(
	's' => $search,
);
```

---

## 2. Direct Database Query Vulnerabilities

### Unsafe Query Patterns

```php
// ❌ BAD - String concatenation
global $wpdb;
$user_id = $_GET['user_id'];
$query = "SELECT * FROM {$wpdb->users} WHERE ID = $user_id";
$results = $wpdb->get_results( $query );

// ✅ GOOD - Use wpdb::prepare()
$user_id = absint( $_GET['user_id'] );
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->users} WHERE ID = %d",
	$user_id
);
$results = $wpdb->get_results( $query );
```

### LIKE Query Vulnerabilities

```php
// ❌ BAD - Direct LIKE without esc_like()
global $wpdb;
$search = $_GET['search'];
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
	'%' . $search . '%' // Vulnerable to LIKE injection!
);

// ✅ GOOD - Use esc_like() before prepare()
$search = $wpdb->esc_like( sanitize_text_field( $_GET['search'] ) );
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
	'%' . $search . '%'
);
```

### Table/Field Name Vulnerabilities

```php
// ❌ BAD - User input as table/field name
global $wpdb;
$table = $_GET['table'];
$query = "SELECT * FROM $table"; // Vulnerable!

// ✅ GOOD - Use identifier placeholder (WP 6.2+)
$table = sanitize_key( $_GET['table'] );
$query = $wpdb->prepare(
	"SELECT * FROM %i",
	$table
);

// OR whitelist approach
$allowed_tables = array( 'posts', 'users', 'comments' );
$table = sanitize_key( $_GET['table'] );
if ( ! in_array( $table, $allowed_tables, true ) ) {
	wp_die( 'Invalid table' );
}
$query = "SELECT * FROM {$wpdb->$table}";
```

---

## 3. Taxonomy Query Vulnerabilities

### Unsafe Taxonomy Queries

```php
// ❌ BAD - Unsanitized taxonomy terms
$args = array(
	'tax_query' => array(
		array(
			'taxonomy' => $_GET['taxonomy'], // Vulnerable!
			'field' => 'slug',
			'terms' => $_GET['terms'], // Vulnerable!
		),
	),
);

// ✅ GOOD - Sanitize taxonomy and terms
$taxonomy = sanitize_key( $_GET['taxonomy'] );
$terms = array_map( 'sanitize_text_field', (array) $_GET['terms'] );

$args = array(
	'tax_query' => array(
		array(
			'taxonomy' => $taxonomy,
			'field' => 'slug',
			'terms' => $terms,
		),
	),
);
```

---

## 4. Post Meta Update Vulnerabilities

### Unsafe Meta Updates

```php
// ❌ BAD - Direct user input
update_post_meta( $post_id, $_GET['key'], $_GET['value'] );

// ✅ GOOD - Sanitize both key and value
$meta_key = sanitize_key( $_GET['key'] );
$meta_value = sanitize_text_field( $_GET['value'] );
update_post_meta( $post_id, $meta_key, $meta_value );
```

---

## 5. User Input in Query Arguments

### Unsafe Query Argument Construction

```php
// ❌ BAD - Building query args from user input without sanitization
$args = array();
if ( isset( $_GET['post_type'] ) ) {
	$args['post_type'] = $_GET['post_type']; // Vulnerable!
}
if ( isset( $_GET['author'] ) ) {
	$args['author'] = $_GET['author']; // Vulnerable!
}
if ( isset( $_GET['orderby'] ) ) {
	$args['orderby'] = $_GET['order_by']; // Vulnerable!
}

// ✅ GOOD - Sanitize all query arguments
$args = array();
if ( isset( $_GET['post_type'] ) ) {
	$post_type = sanitize_key( $_GET['post_type'] );
	if ( post_type_exists( $post_type ) ) {
		$args['post_type'] = $post_type;
	}
}
if ( isset( $_GET['author'] ) ) {
	$args['author'] = absint( $_GET['author'] );
}
if ( isset( $_GET['orderby'] ) ) {
	$orderby = sanitize_key( $_GET['orderby'] );
	$allowed = array( 'date', 'title', 'author' );
	if ( in_array( $orderby, $allowed, true ) ) {
		$args['orderby'] = $orderby;
	}
}
```

---

## 6. Common Vulnerable Patterns

### Pattern 1: Direct Superglobal in Query

```php
// ❌ BAD
$query = new WP_Query( array(
	'post_type' => $_GET['type'],
	'meta_key' => $_GET['key'],
	'meta_value' => $_GET['value'],
) );

// ✅ GOOD
$query = new WP_Query( array(
	'post_type' => sanitize_key( $_GET['type'] ),
	'meta_key' => sanitize_key( $_GET['key'] ),
	'meta_value' => sanitize_text_field( $_GET['value'] ),
) );
```

### Pattern 2: Building SQL Strings

```php
// ❌ BAD
global $wpdb;
$where = "WHERE post_status = '" . $_GET['status'] . "'";
$query = "SELECT * FROM {$wpdb->posts} $where";

// ✅ GOOD
$status = sanitize_text_field( $_GET['status'] );
$query = $wpdb->prepare(
	"SELECT * FROM {$wpdb->posts} WHERE post_status = %s",
	$status
);
```

### Pattern 3: Dynamic Query Building

```php
// ❌ BAD
$conditions = array();
if ( isset( $_GET['category'] ) ) {
	$conditions[] = "term_id = " . $_GET['category'];
}
$where = implode( ' AND ', $conditions );
$query = "SELECT * FROM {$wpdb->terms} WHERE $where";

// ✅ GOOD
$conditions = array();
$placeholders = array();
if ( isset( $_GET['category'] ) ) {
	$category = absint( $_GET['category'] );
	$conditions[] = "term_id = %d";
	$placeholders[] = $category;
}
if ( ! empty( $conditions ) ) {
	$where = implode( ' AND ', $conditions );
	$query = $wpdb->prepare(
		"SELECT * FROM {$wpdb->terms} WHERE $where",
		...$placeholders
	);
}
```

---

## 7. Auditing Plugin Code

### Red Flags to Look For

1. **Direct `$_GET`/`$_POST` in queries:**
```php
// Red flag
$wpdb->query( "SELECT * FROM table WHERE id = " . $_GET['id'] );
```

2. **Unsanitized meta keys:**
```php
// Red flag
'meta_key' => $_GET['key']
```

3. **String concatenation in SQL:**
```php
// Red flag
$sql = "SELECT * FROM table WHERE field = '" . $user_input . "'";
```

4. **No prepared statements:**
```php
// Red flag
$wpdb->query( $sql ); // Where $sql contains user input
```

### Safe Patterns

1. **Always use `wpdb::prepare()`:**
```php
$query = $wpdb->prepare( "SELECT * FROM table WHERE id = %d", $id );
```

2. **Sanitize meta keys:**
```php
'meta_key' => sanitize_key( $_GET['key'] )
```

3. **Use `esc_like()` for LIKE queries:**
```php
$search = $wpdb->esc_like( $search );
$query = $wpdb->prepare( "SELECT * FROM table WHERE field LIKE %s", '%' . $search . '%' );
```

4. **Whitelist approach for dynamic values:**
```php
$allowed = array( 'value1', 'value2' );
if ( ! in_array( $input, $allowed, true ) ) {
	wp_die( 'Invalid value' );
}
```

---

## Exam Tips

### Key Points to Remember

1. **Meta Query Security:**
   - Always sanitize meta keys with `sanitize_key()`
   - Sanitize meta values with appropriate functions
   - WordPress handles meta values safely, but keys must be sanitized

2. **Search Security:**
   - WordPress search is generally safe
   - For custom search, use `esc_like()` before `prepare()`
   - Sanitize search input with `sanitize_text_field()`

3. **Direct Queries:**
   - Always use `wpdb::prepare()` for custom queries
   - Use `esc_like()` for LIKE queries
   - Use `%i` placeholder for identifiers (WP 6.2+)

4. **Query Arguments:**
   - Sanitize all user input in query arguments
   - Validate against whitelists where possible
   - Use type-specific sanitization functions

5. **Common Mistakes:**
   - Using user input directly in meta_query keys
   - Building SQL strings with concatenation
   - Not sanitizing taxonomy/term inputs
   - Trusting data from `$_GET`/`$_POST` in queries

---

## Additional Resources

- [Data Validation - WordPress Developer Resources](https://developer.wordpress.org/apis/handbook/validation/)
- [WP_Query - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_query/)
- [WP_Meta_Query - WordPress Developer Resources](https://developer.wordpress.org/reference/classes/wp_meta_query/)
- Core Files:
  - `wp-includes/class-wp-query.php` - Query parsing
  - `wp-includes/class-wp-meta-query.php` - Meta query handling
  - `wp-includes/class-wpdb.php` - Database abstraction
